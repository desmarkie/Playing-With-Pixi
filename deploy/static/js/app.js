// Generated by CoffeeScript 1.6.3
var App, ColourConversion, CometParticle, CometSparkParticle, Comets, Dots, Fractals, InfoPanel, MathUtils, Menu, MenuButton, Node, Orbits, PWPData, PictureTile, Plankton, PlanktonTank, Point, Radar, Ribbon, ShapeShifter, SineWave, Sketch, Smoky, Spirals, Spirograph, SpirographNode, SquidNode, Squids, Stacks, Trails,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Sketch = (function() {
  Sketch.prototype.view = null;

  Sketch.prototype.cancelled = false;

  Sketch.prototype.loaded = false;

  Sketch.prototype.renderer = null;

  Sketch.prototype.stage = null;

  function Sketch(renderer) {
    this.renderer = renderer;
  }

  Sketch.prototype.load = function() {
    this.cancelled = false;
    if (!this.loaded) {
      requestAnimationFrame(this.update);
    }
    this.loaded = true;
    this.stage.visible = true;
    return null;
  };

  Sketch.prototype.unload = function() {
    this.cancelled = true;
    this.stage.visible = false;
    return null;
  };

  Sketch.prototype.update = function() {
    requestAnimationFrame(this.update);
    if (this.cancelled) {
      return;
    }
    return null;
  };

  Sketch.prototype.resize = function() {
    return null;
  };

  Sketch.prototype.makeGui = function() {
    var gui;
    gui = new dat.GUI({
      autoPlace: false
    });
    gui.domElement.style.zIndex = 100;
    gui.domElement.style.position = 'absolute';
    gui.domElement.style.top = 0;
    gui.domElement.style.left = 0;
    gui.domElement.style.height = 'auto';
    return gui;
  };

  return Sketch;

})();

/*
Colour conversion utils
Mostly nicked from the interwebs

Main source: http://blog.crondesign.com/2011/02/actionscriptjavascript-colour-mode.html
hsbToRgb conversion from: http://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
*/


ColourConversion = (function() {
  function ColourConversion() {}

  ColourConversion.hexToRgb = function(hex) {
    var rgb;
    rgb = [];
    rgb.push(hex >> 16);
    rgb.push(hex >> 8 & 0xFF);
    rgb.push(hex & 0xFF);
    return rgb;
  };

  ColourConversion.rgbToHex = function(rgb) {
    var hex;
    hex = rgb[0] << 16 ^ rgb[1] << 8 ^ rgb[2];
    return hex;
  };

  ColourConversion.hsbToRgb = function(hsb) {
    var b, check, f, g, h, i, p, q, r, s, t, v;
    h = hsb[0] / 360;
    s = hsb[1] / 100;
    v = hsb[2] / 100;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    check = i % 6;
    if (check === 0) {
      r = v;
      g = t;
      b = p;
    }
    if (check === 1) {
      r = q;
      g = v;
      b = p;
    }
    if (check === 2) {
      r = p;
      g = v;
      b = t;
    }
    if (check === 3) {
      r = p;
      g = q;
      b = v;
    }
    if (check === 4) {
      r = t;
      g = p;
      b = v;
    }
    if (check === 5) {
      r = v;
      g = p;
      b = q;
    }
    return [r * 255, g * 255, b * 255];
  };

  ColourConversion.rgbToHsb = function(rgb) {
    var f, hue, i, sat, val, x;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;
    x = Math.min(Math.min(rgb[0], rgb[1]), rgb[2]);
    val = Math.max(Math.max(rgb[0], rgb[1]), rgb[2]);
    if (x === val) {
      return [void 0, 0, val * 100];
    }
    if (x === rgb[0]) {
      f = rgb[1] - rgb[2];
    } else if (x === rgb[1]) {
      f = rgb[2] - rgb[0];
    } else {
      f = rgb[0] - rgb[1];
    }
    if (x === rgb[0]) {
      i = 3;
    } else if (x === rgb[1]) {
      i = 5;
    } else {
      i = 1;
    }
    hue = Math.floor((i - f / (val - x)) * 60) % 360;
    sat = Math.floor(((val - x) / val) * 100);
    val = Math.floor(val * 100);
    return [hue, sat, val];
  };

  ColourConversion.hsbToHex = function(hsb) {
    var rgb;
    rgb = ColourConversion.hsbToRgb(hsb);
    return ColourConversion.rgbToHex(rgb);
  };

  ColourConversion.hexToHsb = function(hex) {
    var rgb;
    rgb = ColourConversion.hexToRgb(hex);
    return ColourConversion.rgbToHsb(rgb);
  };

  return ColourConversion;

})();

Node = (function() {
  function Node(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.fillPositions = __bind(this.fillPositions, this);
    this.checkPositionsLength = __bind(this.checkPositionsLength, this);
    this.moveTo = __bind(this.moveTo, this);
    this.position = new Point(x, y, z);
    this.velocity = new Point();
    this.positions = [];
    this.positions.push(this.position.clone());
    this.recordedPositions = 1;
  }

  Node.prototype.moveTo = function(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.position.x = x;
    this.position.y = y;
    this.position.z = z;
    this.positions.push(this.position.clone());
    this.checkPositionsLength();
    return null;
  };

  Node.prototype.checkPositionsLength = function() {
    while (this.positions.length > this.recordedPositions) {
      this.positions.splice(0, 1);
    }
    return null;
  };

  Node.prototype.fillPositions = function() {
    while (this.positions.length < this.recordedPositions) {
      this.positions.push(this.position.clone());
    }
    return null;
  };

  return Node;

})();

CometSparkParticle = (function(_super) {
  __extends(CometSparkParticle, _super);

  function CometSparkParticle(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.update = __bind(this.update, this);
    this.setColor = __bind(this.setColor, this);
    this.newLife = __bind(this.newLife, this);
    CometSparkParticle.__super__.constructor.call(this, x, y, z);
    this.life = 0;
    this.totalLife = 0;
    this.minLife = 10;
    this.maxLife = 30;
    this.minSpeed = 0.4;
    this.maxSpeed = 1.5;
    this.recordedPositions = 30;
    this.fillPositions();
    this.newLife();
    this.hsb = [300, 66, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.view = new PIXI.Sprite(window.app.textures[0]);
    this.view.pivot.x = this.view.pivot.y = 16;
    this.view.tint = this.hex;
  }

  CometSparkParticle.prototype.newLife = function() {
    this.totalLife = Math.round(this.minLife + (Math.random() * (this.maxLife - this.minLife)));
    this.life = this.totalLife;
    this.velocity.x = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    this.velocity.y = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    if (Math.random() < 0.5) {
      this.velocity.x *= -1;
    }
    if (Math.random() < 0.5) {
      this.velocity.y *= -1;
    }
    return null;
  };

  CometSparkParticle.prototype.setColor = function(value) {
    this.hsb[0] = value;
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.view.tint = this.hex;
    return null;
  };

  CometSparkParticle.prototype.update = function() {
    if (this.life === 0) {
      return;
    }
    this.moveTo(this.position.x + this.velocity.x, this.position.y + this.velocity.y, this.position.z + this.velocity.z);
    this.life--;
    this.view.scale.x = this.view.scale.y = 0.1 + (Math.random() * 0.3);
    this.view.alpha = 0.2 + (Math.random() * 1.2);
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    return null;
  };

  return CometSparkParticle;

})(Node);

CometParticle = (function(_super) {
  __extends(CometParticle, _super);

  function CometParticle(x, y, z) {
    var i, _i, _ref;
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.newSpark = __bind(this.newSpark, this);
    this.fireSpark = __bind(this.fireSpark, this);
    this.updateSparks = __bind(this.updateSparks, this);
    this.update = __bind(this.update, this);
    this.headForMouse = __bind(this.headForMouse, this);
    this.randomiseVelocity = __bind(this.randomiseVelocity, this);
    this.setSparkColor = __bind(this.setSparkColor, this);
    this.setColor = __bind(this.setColor, this);
    CometParticle.__super__.constructor.call(this, x, y, z);
    this.life = 240;
    this.totalLife = 240;
    this.maxSpeed = 40;
    this.minSpeed = 20;
    this.children = [];
    this.pool = [];
    this.maxChildren = 5;
    this.recordedPositions = 30;
    this.fillPositions();
    this.view = new PIXI.DisplayObjectContainer();
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.main = new PIXI.Sprite(window.app.textures[0]);
    this.main.pivot.x = this.main.pivot.y = 16;
    this.color = 240;
    this.setColor(this.color);
    this.sparkColor = 300;
    this.view.addChild(this.main);
    for (i = _i = 0, _ref = this.maxChildren; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.fireSpark();
    }
  }

  CometParticle.prototype.setColor = function(value) {
    var hex, hsb;
    this.color = value;
    hsb = [this.color, 18, 100];
    hex = ColourConversion.hsbToHex(hsb);
    this.main.tint = hex;
    return null;
  };

  CometParticle.prototype.setSparkColor = function(value) {
    var spark, _i, _len, _ref;
    this.sparkColor = value;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      spark = _ref[_i];
      spark.setColor(this.sparkColor);
    }
    return null;
  };

  CometParticle.prototype.randomiseVelocity = function(ranx, rany) {
    if (ranx == null) {
      ranx = true;
    }
    if (rany == null) {
      rany = true;
    }
    if (ranx) {
      this.velocity.x = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    }
    if (rany) {
      this.velocity.y = -(this.maxSpeed * 0.1) + (Math.random() * (this.maxSpeed * 0.2));
    }
    return null;
  };

  CometParticle.prototype.headForMouse = function() {
    var easing, xdif, ydif;
    easing = 25;
    xdif = window.app.pointerPosition.x - this.position.x;
    ydif = window.app.pointerPosition.y - this.position.y;
    this.velocity.x = xdif / easing;
    this.velocity.y = ydif / easing;
    return null;
  };

  CometParticle.prototype.update = function() {
    if (this.life === 0) {
      return;
    }
    this.moveTo(this.position.x + this.velocity.x, this.position.y + this.velocity.y, this.position.z + this.velocity.z);
    this.velocity.x *= 0.98;
    this.velocity.y *= 0.98;
    this.velocity.z *= 0.98;
    this.life--;
    this.main.scale.x = this.main.scale.y = 0.7 + (Math.random() * 2);
    this.view.alpha = this.life / this.totalLife;
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.updateSparks();
    while (this.children.length < this.maxChildren) {
      this.fireSpark();
    }
    return null;
  };

  CometParticle.prototype.updateSparks = function() {
    var i, spark, _i, _ref;
    for (i = _i = _ref = this.children.length - 1; _i >= 0; i = _i += -1) {
      spark = this.children[i];
      spark.update();
      if (spark.life === 0) {
        this.children.splice(i, 1);
        this.pool.push(spark);
        this.view.removeChild(spark.view);
      }
    }
    return null;
  };

  CometParticle.prototype.fireSpark = function() {
    var spark;
    spark = this.newSpark();
    this.children.push(spark);
    this.view.addChild(spark.view);
    return null;
  };

  CometParticle.prototype.newSpark = function() {
    var spark;
    if (this.pool.length > 0) {
      spark = this.pool[0];
      this.pool.splice(0, 1);
    } else {
      spark = new CometSparkParticle();
      spark.setColor(this.sparkColor);
    }
    spark.position.x = 0;
    spark.position.y = 0;
    spark.positions = [];
    spark.fillPositions();
    spark.newLife();
    return spark;
  };

  return CometParticle;

})(Node);

Comets = (function(_super) {
  __extends(Comets, _super);

  Comets.prototype.particles = [];

  Comets.prototype.pool = [];

  function Comets(renderer) {
    this.renderer = renderer;
    this.resize = __bind(this.resize, this);
    this.newTimeLimit = __bind(this.newTimeLimit, this);
    this.newComet = __bind(this.newComet, this);
    this.setCometColors = __bind(this.setCometColors, this);
    this.fireComet = __bind(this.fireComet, this);
    this.drawPaths = __bind(this.drawPaths, this);
    this.setSparkColor = __bind(this.setSparkColor, this);
    this.setTrailColor = __bind(this.setTrailColor, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Comets.__super__.constructor.call(this, this.renderer);
  }

  Comets.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.maxComets = 40;
      this.minFrames = 5;
      this.maxFrames = 10;
      this.timeLimit = 0;
      this.cometColor = 240;
      this.sparkColor = 300;
      this.trailColor = 240;
      this.trailHsb = [0, 18, 100];
      this.setTrailColor(this.trailColor);
      this.newTimeLimit();
      this.gui.add(this, 'maxComets', 1, 100);
      this.gui.add(this, 'minFrames', 1, 100);
      this.gui.add(this, 'maxFrames', 1, 100);
      this.gui.add(this, 'cometColor', 0, 360).onFinishChange(function() {
        return _this.setCometColors();
      });
      this.gui.add(this, 'trailColor', 0, 360).onChange(function() {
        return _this.setTrailColor(_this.trailColor);
      });
      this.gui.add(this, 'sparkColor', 0, 360).onChange(function() {
        return _this.setSparkColor(_this.sparkColor);
      });
      this.graphics = new PIXI.Graphics();
      this.stage.addChild(this.graphics);
    }
    this.view.appendChild(this.renderer.view);
    this.timeout = 1;
    Comets.__super__.load.call(this);
    return null;
  };

  Comets.prototype.unload = function() {
    Comets.__super__.unload.call(this);
    return null;
  };

  Comets.prototype.update = function() {
    var comet, i, _i, _ref;
    Comets.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.timeout--;
    if (this.timeout === 0) {
      if (this.particles.length < this.maxComets) {
        this.newTimeLimit();
        this.timeout = this.timeLimit;
        this.fireComet();
      } else {
        this.timeout++;
      }
    }
    for (i = _i = _ref = this.particles.length - 1; _i >= 0; i = _i += -1) {
      comet = this.particles[i];
      comet.randomiseVelocity(false);
      if (window.app.mousePressed) {
        comet.headForMouse();
      }
      comet.update();
      if (comet.life === 0 || comet.position.x > window.innerWidth) {
        this.particles.splice(i, 1);
        this.pool.push(comet);
        this.stage.removeChild(comet.view);
      }
    }
    this.drawPaths();
    this.renderer.render(this.stage);
    return null;
  };

  Comets.prototype.setTrailColor = function(value) {
    this.trailColor = value;
    this.trailHsb[0] = this.trailColor;
    this.trailHex = ColourConversion.hsbToHex(this.trailHsb);
    return null;
  };

  Comets.prototype.setSparkColor = function(value) {
    var comet, _i, _len, _ref;
    this.sparkColor = value;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      comet.setSparkColor(this.sparkColor);
    }
    return null;
  };

  Comets.prototype.drawPaths = function() {
    var comet, i, inc, _i, _j, _len, _ref, _ref1;
    this.graphics.clear();
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      inc = 1 / comet.positions.length;
      for (i = _j = 0, _ref1 = comet.positions.length - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.graphics.lineStyle(1, this.trailHex, (i * inc) * (comet.life / comet.totalLife));
        this.graphics.moveTo(comet.positions[i].x, comet.positions[i].y);
        this.graphics.lineTo(comet.positions[i + 1].x, comet.positions[i + 1].y);
      }
    }
    return null;
  };

  Comets.prototype.fireComet = function() {
    var comet;
    comet = this.newComet();
    this.particles.push(comet);
    this.stage.addChild(comet.view);
    return null;
  };

  Comets.prototype.setCometColors = function() {
    var comet, _i, _len, _ref;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      comet.setColor(this.cometColor);
    }
    return null;
  };

  Comets.prototype.newComet = function() {
    var comet;
    if (this.pool.length === 0) {
      comet = new CometParticle();
    } else {
      comet = this.pool[0];
      this.pool.splice(0, 1);
    }
    comet.setColor(this.cometColor);
    comet.setSparkColor(this.sparkColor);
    comet.position.x = 0;
    comet.position.y = Math.random() * window.innerHeight;
    comet.randomiseVelocity();
    comet.positions = [];
    comet.fillPositions();
    comet.life = comet.totalLife;
    return comet;
  };

  Comets.prototype.newTimeLimit = function() {
    this.timeLimit = Math.round(this.minFrames + (Math.random() * (this.maxFrames - this.minFrames)));
    return null;
  };

  Comets.prototype.resize = function() {
    return null;
  };

  return Comets;

})(Sketch);

Dots = (function(_super) {
  __extends(Dots, _super);

  Dots.id = 'Dots';

  Dots.prototype.dots = [];

  Dots.prototype.deadDots = [];

  Dots.prototype.xCounter = 0;

  Dots.prototype.xLimit = 0;

  Dots.prototype.xDir = 1;

  Dots.prototype.yCounter = 0;

  Dots.prototype.yLimit = 0;

  Dots.prototype.yDir = 1;

  Dots.prototype.curX = 0;

  Dots.prototype.curY = 0;

  Dots.prototype.mouseX = 0;

  Dots.prototype.mouseY = 0;

  Dots.prototype.easeX = 0;

  Dots.prototype.easeY = 0;

  Dots.prototype.spriteSize = 32;

  Dots.prototype.invert = true;

  Dots.prototype.mouseTrail = true;

  Dots.prototype.xFollow = false;

  Dots.prototype.xBounce = true;

  Dots.prototype.xLeft = false;

  Dots.prototype.xRight = false;

  Dots.prototype.xOff = false;

  Dots.prototype.lastX = 'follow';

  Dots.prototype.yFollow = false;

  Dots.prototype.yBounce = false;

  Dots.prototype.yUp = false;

  Dots.prototype.yDown = true;

  Dots.prototype.yOff = false;

  Dots.prototype.lastY = 'follow';

  function Dots(renderer) {
    this.renderer = renderer;
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.updateGui = __bind(this.updateGui, this);
    Dots.__super__.constructor.call(this, this.renderer);
  }

  Dots.prototype.updateGui = function() {
    var c, _i, _len, _ref;
    _ref = this.gui.__controllers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.updateDisplay();
    }
    return null;
  };

  Dots.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'spriteSize', 16, 128, 8).onFinishChange(function(val) {
        _this.spriteSize = val;
        return _this.resize();
      });
      this.gui.add(this, 'invert');
      this.gui.add(this, 'mouseTrail');
      this.gui.add(this, 'xFollow').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xFollow = true) {
          _this.xBounce = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'follow';
          _this.xBounce = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xBounce').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xBounce = true) {
          _this.xFollow = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'bounce';
          _this.xFollow = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xLeft').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xLeft = true) {
          _this.xDir = -1;
          _this.xFollow = _this.xBounce = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'left';
          _this.xFollow = _this.xBounce = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xRight').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xRight = true) {
          _this.xDir = 1;
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xOff = false;
        } else {
          _this.lastX = 'right';
          _this.xFollow = _this.xBounce = _this.xLeft = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xOff').onChange(function(val) {
        _this.xOff = val;
        if (_this.xOff) {
          if (_this.xFollow) {
            _this.lastX = 'follow';
          } else if (_this.xBounce) {
            _this.lastX = 'bounce';
          } else if (_this.xLeft) {
            _this.lastX = 'left';
          } else if (_this.xRight) {
            _this.lastX = 'right';
          }
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xRight = false;
        } else {
          if (_this.lastX === 'follow') {
            _this.xFollow = true;
          } else if (_this.lastX === 'bounce') {
            _this.xBounce = true;
          } else if (_this.lastX === 'left') {
            _this.xLeft = true;
          } else if (_this.lastX === 'right') {
            _this.xRight = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yFollow').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yFollow = true) {
          _this.yBounce = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'follow';
          _this.yBounce = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yBounce').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yBounce = true) {
          _this.yFollow = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'bounce';
          _this.yFollow = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yUp').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yUp = true) {
          _this.yDir = -1;
          _this.yFollow = _this.yBounce = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'left';
          _this.yFollow = _this.yBounce = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yDown').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yDown = true) {
          _this.yDir = 1;
          _this.yFollow = _this.yBounce = _this.yUp = _this.yOff = false;
        } else {
          _this.lastY = 'right';
          _this.yFollow = _this.yBounce = _this.yUp = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yOff').onChange(function(val) {
        _this.yOff = val;
        if (_this.yOff) {
          if (_this.yFollow) {
            _this.lastY = 'follow';
          } else if (_this.yBounce) {
            _this.lastY = 'bounce';
          } else if (_this.yUp) {
            _this.lastY = 'up';
          } else if (_this.yDown) {
            _this.lastY = 'down';
          }
          _this.yFollow = _this.yBounce = _this.yUp = _this.yDown = false;
        } else {
          if (_this.lastY === 'follow') {
            _this.yFollow = true;
          } else if (_this.lastY === 'bounce') {
            _this.yBounce = true;
          } else if (_this.lastY === 'up') {
            _this.yUp = true;
          } else if (_this.lastY === 'down') {
            _this.yDown = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.close();
    }
    Dots.__super__.load.call(this);
    this.view.appendChild(this.renderer.view);
    this.xLimit = this.dots.length;
    this.yLimit = this.dots[0].length;
    return null;
  };

  Dots.prototype.unload = function() {
    Dots.__super__.unload.call(this);
    return null;
  };

  Dots.prototype.update = function() {
    var i, j, sprite, tgtAlpha, _i, _j, _ref, _ref1;
    Dots.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.handleMouseMove();
    if (this.xFollow) {
      this.xCounter = this.curX;
    }
    if (this.yFollow) {
      this.yCounter = this.curY;
    }
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        sprite = this.dots[i][j];
        tgtAlpha = 1;
        if (this.invert) {
          tgtAlpha = 0;
        }
        if (!this.xOff && i === this.xCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (!this.yOff && j === this.yCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (this.invert) {
          if (sprite.alpha < 1) {
            sprite.alpha += 0.05;
            sprite.scale.x += 0.05;
            sprite.scale.y += 0.05;
            if (sprite.alpha > 1) {
              sprite.alpha = 1;
            }
            if (sprite.scale.x > 1) {
              sprite.scale.x = sprite.scale.y = this.spriteSize / 32;
            }
          }
        } else {
          if (sprite.alpha > 0) {
            sprite.alpha -= 0.05;
            sprite.scale.x -= 0.05;
            sprite.scale.y -= 0.05;
            if (sprite.alpha < 0) {
              sprite.alpha = 0;
            }
            if (sprite.scale.x < 0) {
              sprite.scale.x - (sprite.scale.y = 0);
            }
          }
        }
      }
    }
    if (!this.xOff) {
      this.xCounter += this.xDir;
      if (this.xLeft || this.xRight) {
        this.xCounter %= this.xLimit;
        if (this.xCounter < 0) {
          this.xCounter = this.xLimit - 1;
        }
      } else if (this.xBounce) {
        if (this.xCounter === this.xLimit) {
          this.xCounter = this.xLimit - 2;
          this.xDir *= -1;
        } else if (this.xCounter < 0) {
          this.xCounter = 1;
          this.xDir *= -1;
        }
      }
    }
    if (!this.yOff) {
      this.yCounter += this.yDir;
      if (this.yUp || this.yDown) {
        this.yCounter %= this.yLimit;
        if (this.yCounter < 0) {
          this.yCounter = this.yLimit - 1;
        }
      } else if (this.yBounce) {
        if (this.yCounter === this.yLimit) {
          this.yCounter = this.yLimit - 2;
          this.yDir *= -1;
        } else if (this.yCounter < 0) {
          this.yCounter = 1;
          this.yDir *= -1;
        }
      }
    }
    this.easeX += (this.mouseX - this.easeX) / 45;
    this.easeY += (this.mouseY - this.easeY) / 45;
    this.curX = Math.floor(this.easeX / this.spriteSize);
    this.curY = Math.floor(this.easeY / this.spriteSize);
    this.renderer.render(this.stage);
    return null;
  };

  Dots.prototype.resize = function() {
    var i, j, _i, _j, _ref, _ref1;
    if (this.loaded) {
      for (i = _i = _ref = this.dots.length - 1; _i >= 0; i = _i += -1) {
        for (j = _j = _ref1 = this.dots[i].length - 1; _j >= 0; j = _j += -1) {
          this.stage.removeChild(this.dots[i][j]);
          this.dots[i].splice(j, 1);
        }
      }
      this.dots = [];
      this.createSprites();
      this.xLimit = this.dots.length;
      this.yLimit = this.dots[0].length;
    }
    return null;
  };

  Dots.prototype.handleMouseMove = function() {
    var tgtAlpha, xid, yid;
    this.mouseX = window.app.pointerPosition.x;
    this.mouseY = window.app.pointerPosition.y;
    if (this.mouseTrail) {
      xid = Math.floor(this.mouseX / this.spriteSize);
      yid = Math.floor(this.mouseY / this.spriteSize);
      tgtAlpha = 1;
      if (this.invert) {
        tgtAlpha = 0;
      }
      this.dots[xid][yid].alpha = tgtAlpha;
      if (this.dots[xid] && this.dots[xid][yid - 1]) {
        this.dots[xid][yid - 1].alpha = tgtAlpha;
        this.dots[xid][yid - 1].scale.x = this.dots[xid][yid - 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid] && this.dots[xid][yid + 1]) {
        this.dots[xid][yid + 1].alpha = tgtAlpha;
        this.dots[xid][yid + 1].scale.x = this.dots[xid][yid + 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid - 1] && this.dots[xid - 1][yid]) {
        this.dots[xid - 1][yid].alpha = tgtAlpha;
        this.dots[xid - 1][yid].scale.x = this.dots[xid - 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid + 1] && this.dots[xid + 1][yid]) {
        this.dots[xid + 1][yid].alpha = tgtAlpha;
        this.dots[xid + 1][yid].scale.x = this.dots[xid + 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
    }
    return null;
  };

  Dots.prototype.createSprites = function() {
    var i, j, sp, _i, _j, _ref, _ref1;
    this.xCount = Math.round(window.innerWidth / this.spriteSize);
    this.yCount = Math.round(window.innerHeight / this.spriteSize);
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      this.dots[i] = [];
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        if (this.deadDots.length === 0) {
          sp = new PIXI.Sprite(window.app.textures[0]);
        } else {
          sp = this.deadDots[0];
          this.deadDots.splice(0, 1);
        }
        sp.scale.x = sp.scale.y = this.spriteSize / 32;
        sp.position.x = i * this.spriteSize;
        sp.position.y = j * this.spriteSize;
        this.dots[i][j] = sp;
        sp.alpha = 0;
        this.stage.addChild(sp);
      }
    }
    return null;
  };

  return Dots;

})(Sketch);

Fractals = (function(_super) {
  __extends(Fractals, _super);

  Fractals.prototype.minSize = 32;

  Fractals.prototype.startSize = 400;

  Fractals.prototype.divisor = 2.5;

  Fractals.prototype.sprites = [];

  Fractals.prototype.deadSprites = [];

  function Fractals(renderer) {
    this.renderer = renderer;
    this.getSprite = __bind(this.getSprite, this);
    this.addSprite = __bind(this.addSprite, this);
    this.redraw = __bind(this.redraw, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Fractals.__super__.constructor.call(this, this.renderer);
  }

  Fractals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderView = new PIXI.Sprite(this.renderTex);
      this.stage.addChild(this.renderView);
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.canvas = new PIXI.DisplayObjectContainer();
      this.gui.add(this, 'minSize', 1, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'startSize', 10, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'divisor', 2, 6).onFinishChange(function() {
        return _this.redraw();
      });
    }
    this.createSprites();
    this.view.appendChild(this.renderer.view);
    Fractals.__super__.load.call(this);
    return null;
  };

  Fractals.prototype.unload = function() {
    Fractals.__super__.unload.call(this);
    return null;
  };

  Fractals.prototype.update = function() {
    Fractals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.renderer.render(this.stage);
    return null;
  };

  Fractals.prototype.resize = function() {
    this.redraw();
    return null;
  };

  Fractals.prototype.redraw = function() {
    if (this.renderView) {
      this.renderTex.destroy();
      this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderView.setTexture(this.renderTex);
      this.sprites = [];
      this.createSprites();
    }
    return null;
  };

  Fractals.prototype.createSprites = function() {
    this.addSprite(window.innerWidth * 0.5, window.innerHeight * 0.5, this.startSize);
    return null;
  };

  Fractals.prototype.addSprite = function(x, y, size) {
    var _this = this;
    this.sprite.position.x = x;
    this.sprite.position.y = y;
    this.sprite.scale.x = this.sprite.scale.y = size / 32;
    this.canvas.addChild(this.sprite);
    this.renderTex.render(this.canvas);
    this.canvas.removeChild(this.sprite);
    if (size > this.minSize) {
      return setTimeout(function() {
        _this.addSprite(x + size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x - size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x, y + size / _this.divisor, size / _this.divisor);
        return _this.addSprite(x, y - size / _this.divisor, size / _this.divisor);
      }, 500);
    }
  };

  Fractals.prototype.getSprite = function() {
    if (this.deadSprites.length === 0) {
      return new PIXI.Sprite(window.app.textures[0]);
    } else {
      return this.deadSprites.splice(0, 1)[0];
    }
  };

  return Fractals;

})(Sketch);

Orbits = (function(_super) {
  __extends(Orbits, _super);

  function Orbits(renderer) {
    this.renderer = renderer;
    this.drawTail = __bind(this.drawTail, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Orbits.__super__.constructor.call(this, this.renderer);
  }

  Orbits.prototype.load = function() {
    var i, n, tx, ty, _i, _ref;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 19.6;
      this.baseNode.yIncrement = 35.2;
      this.baseNode.xOffset = 726;
      this.baseNode.yOffset = 217;
      this.numSattelites = 10;
      this.easing = 50;
      this.tailLength = 60;
      this.tailWidth = 6.2;
      this.initialSpacing = 60;
      this.nodes = [];
      this.maxSpeed = 175;
      this.tailColour = 0x8CF1FF;
      for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        tx = this.midx + (Math.cos(Math.random() * Math.PI) * this.initialSpacing);
        ty = this.midy + (Math.sin(Math.random() * Math.PI) * this.initialSpacing);
        n = new Node(tx, ty);
        n.recordedPositions = this.tailLength;
        n.fillPositions();
        this.nodes.push(n);
      }
      this.graphics = new PIXI.Graphics();
      this.stage.addChild(this.graphics);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this, 'tailWidth', 2, 100);
      this.gui.add(this, 'maxSpeed', 2, 1000);
      this.gui.add(this, 'easing', 2, 100);
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
    }
    this.view.appendChild(this.renderer.view);
    Orbits.__super__.load.call(this);
    return null;
  };

  Orbits.prototype.unload = function() {
    Orbits.__super__.unload.call(this);
    return null;
  };

  Orbits.prototype.update = function() {
    var i, n, newx, newy, xdif, ydif, _i, _ref;
    Orbits.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.graphics.clear();
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(this.baseNode.xSin * window.app.degToRad) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(this.baseNode.ySin * window.app.degToRad) * this.baseNode.yOffset);
    for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = this.nodes[i];
      xdif = this.baseNode.position.x - n.position.x;
      ydif = this.baseNode.position.y - n.position.y;
      n.velocity.x += xdif / this.easing;
      n.velocity.y += ydif / this.easing;
      if (n.velocity.x > this.maxSpeed) {
        n.velocity.x = this.maxSpeed;
      } else if (n.velocity.x < -this.maxSpeed) {
        n.velocity.x = -this.maxSpeed;
      }
      if (n.velocity.y > this.maxSpeed) {
        n.velocity.y = this.maxSpeed;
      } else if (n.velocity.y < -this.maxSpeed) {
        n.velocity.y = -this.maxSpeed;
      }
      newx = n.position.x + n.velocity.x;
      newy = n.position.y + n.velocity.y;
      n.moveTo(newx, newy);
      this.drawTail(n);
    }
    this.renderer.render(this.stage);
    return null;
  };

  Orbits.prototype.resize = function() {
    return null;
  };

  Orbits.prototype.drawTail = function(node) {
    var i, inc, pt1, pt2, tailInc, _i, _ref;
    inc = 1 / this.tailLength;
    tailInc = this.tailWidth / this.tailLength;
    for (i = _i = 0, _ref = this.tailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.tailWidth > 1) {
        this.graphics.lineStyle(tailInc * i, this.tailColour, i * inc);
      } else {
        this.graphics.lineStyle(this.tailWidth, this.tailColour, i * inc);
      }
      pt1 = node.positions[i];
      pt2 = node.positions[i + 1];
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt2.x, pt2.y);
    }
    return null;
  };

  return Orbits;

})(Sketch);

PictureTile = (function(_super) {
  __extends(PictureTile, _super);

  function PictureTile(renderer) {
    this.renderer = renderer;
    this.drawPixels = __bind(this.drawPixels, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.handleVideoError = __bind(this.handleVideoError, this);
    this.handleVideo = __bind(this.handleVideo, this);
    this.load = __bind(this.load, this);
    PictureTile.__super__.constructor.call(this, this.renderer);
  }

  PictureTile.prototype.load = function() {
    var i, j, p, sx, sy, _i, _j, _ref, _ref1;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.isConnected = false;
      this.camWidth = 40;
      this.camHeight = 30;
      this.size = 20;
      this.video = document.createElement('video');
      this.video.setAttribute('autoplay', 'true');
      this.video.setAttribute('width', this.camWidth);
      this.video.setAttribute('height', this.camHeight);
      this.video.id = 'videoElement';
      this.video.style.position = 'absolute';
      this.video.style.top = 0;
      this.video.style.left = 0;
      this.video.style.zIndex = 10;
      this.video.style.width = this.camWidth + 'px';
      this.video.style.height = this.camHeight + 'px';
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.camWidth);
      this.canvas.setAttribute('height', this.camHeight);
      this.canvas.style.width = this.camWidth + 'px';
      this.canvas.style.height = this.camHeight + 'px';
      this.canvas.style.position = 'absolute';
      this.canvas.style.top = 0;
      this.canvas.style.left = this.camWidth + 'px';
      this.canvas.style.zIndex = 10;
      sx = ((window.innerWidth - (this.camWidth * this.size)) * 0.5) + 16;
      sy = ((window.innerHeight - (this.camHeight * this.size)) * 0.5) + 16;
      this.sprites = [];
      for (i = _i = 0, _ref = this.camWidth; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sprites[i] = [];
        for (j = _j = 0, _ref1 = this.camHeight; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          p = new PIXI.Sprite(window.app.textures[0]);
          p.pivot.x = p.pivot.y = 16;
          p.position.x = sx + (i * this.size);
          p.position.y = sy + (j * this.size);
          p.scale.x = p.scale.y = this.size / 32;
          this.stage.addChild(p);
          this.sprites[i][j] = p;
        }
      }
    }
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
    if (navigator.getUserMedia) {
      navigator.getUserMedia({
        video: true
      }, this.handleVideo, this.handleVideoError);
    }
    this.view.appendChild(this.renderer.view);
    PictureTile.__super__.load.call(this);
    return null;
  };

  PictureTile.prototype.handleVideo = function(stream) {
    this.isConnected = true;
    this.localStream = stream;
    this.video.src = window.URL.createObjectURL(this.localStream);
    return null;
  };

  PictureTile.prototype.handleVideoError = function(error) {
    if (console) {
      console.log('ERROR :: \n' + error);
    }
    return null;
  };

  PictureTile.prototype.unload = function() {
    if (this.localStream) {
      this.isConnected = false;
      this.localStream.stop();
    }
    PictureTile.__super__.unload.call(this);
    return null;
  };

  PictureTile.prototype.update = function() {
    PictureTile.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (this.isConnected) {
      this.canvas.getContext('2d').drawImage(this.video, 0, 0, this.camWidth, this.camHeight);
      this.drawPixels();
    }
    this.renderer.render(this.stage);
    return null;
  };

  PictureTile.prototype.resize = function() {
    return null;
  };

  PictureTile.prototype.drawPixels = function() {
    var data, hex, hsb, i, offset, rgb, sprite, x, y, _i, _ref;
    data = this.canvas.getContext('2d').getImageData(0, 0, this.camWidth, this.camHeight).data;
    x = 0;
    y = 0;
    for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 4) {
      sprite = this.sprites[x][y];
      rgb = [data[i], data[i + 1], data[i + 2]];
      hex = ColourConversion.rgbToHex(rgb);
      sprite.tint = hex;
      hsb = ColourConversion.hexToHsb(hex);
      offset = hsb[2] * 0.01;
      sprite.scale.x = sprite.scale.y = ((this.size / 32) * 1.5) * offset;
      x++;
      if (x === this.camWidth) {
        x = 0;
        y++;
      }
    }
    return null;
  };

  return PictureTile;

})(Sketch);

PlanktonTank = (function(_super) {
  __extends(PlanktonTank, _super);

  function PlanktonTank(renderer) {
    this.renderer = renderer;
    this.resize = __bind(this.resize, this);
    this.addPlankton = __bind(this.addPlankton, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    PlanktonTank.__super__.constructor.call(this, this.renderer);
  }

  PlanktonTank.prototype.load = function() {
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.numPlankton = 30;
      this.plankton = [];
      this.addPlankton();
    }
    this.view.appendChild(this.renderer.view);
    PlanktonTank.__super__.load.call(this);
    return null;
  };

  PlanktonTank.prototype.unload = function() {
    PlanktonTank.__super__.unload.call(this);
    return null;
  };

  PlanktonTank.prototype.update = function() {
    var p, _i, _len, _ref;
    PlanktonTank.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.plankton;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.update();
    }
    this.renderer.render(this.stage);
    return null;
  };

  PlanktonTank.prototype.addPlankton = function() {
    var i, p, _i, _ref;
    for (i = _i = 0, _ref = this.numPlankton; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      p = new Plankton();
      this.plankton.push(p);
      this.stage.addChild(p.view);
    }
    return null;
  };

  PlanktonTank.prototype.resize = function() {
    return null;
  };

  return PlanktonTank;

})(Sketch);

Radar = (function(_super) {
  __extends(Radar, _super);

  Radar.prototype.numSprites = 60;

  Radar.prototype.radarWidth = 579;

  Radar.prototype.minScale = 0.1;

  Radar.prototype.maxScale = 0.3;

  Radar.prototype.rotation = 0;

  Radar.prototype.rotationSpeed = 238;

  Radar.prototype.midX = 400;

  Radar.prototype.midY = 300;

  Radar.prototype.sprites = [];

  function Radar(renderer) {
    this.renderer = renderer;
    this.createSprites = __bind(this.createSprites, this);
    this.scaleSprites = __bind(this.scaleSprites, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Radar.__super__.constructor.call(this, this.renderer);
    this.midX = window.innerWidth * 0.5;
    this.midY = window.innerHeight * 0.5;
  }

  Radar.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'rotationSpeed', 0.1, 359.9);
      this.gui.add(this, 'radarWidth', 10, 1000);
      this.gui.add(this, 'minScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.gui.add(this, 'maxScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.holder = new PIXI.DisplayObjectContainer();
      this.renderTexture = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderTexture2 = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.dummy = new PIXI.Graphics();
      this.dummy.beginFill(0x000000, 0.05);
      this.dummy.drawRect(0, 0, window.innerWidth, window.innerHeight);
      this.currentTexture = this.renderTexture;
      this.canvas = new PIXI.Sprite(this.currentTexture);
      this.holder.addChild(this.canvas);
      this.stage.addChild(this.holder);
      this.createSprites();
    }
    this.view.appendChild(this.renderer.view);
    Radar.__super__.load.call(this);
    return null;
  };

  Radar.prototype.unload = function() {
    Radar.__super__.unload.call(this);
    return null;
  };

  Radar.prototype.update = function() {
    var i, rot, temp, _i, _ref;
    Radar.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.rotation += this.rotationSpeed;
    rot = this.rotation * window.app.degToRad;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = this.sprites[i];
      this.sprite.position.x = this.midX + (Math.cos(rot) * ((this.radarWidth / this.numSprites) * i));
      this.sprite.position.y = this.midY + (Math.sin(rot) * ((this.radarWidth / this.numSprites) * i));
    }
    temp = this.renderTexture;
    this.renderTexture = this.renderTexture2;
    this.renderTexture2 = temp;
    this.canvas.setTexture(this.renderTexture);
    this.renderTexture2.render(this.holder, new PIXI.Point(0, 0), false);
    this.renderTexture2.render(this.dummy, new PIXI.Point(0, 0), false);
    this.renderer.render(this.stage);
    return null;
  };

  Radar.prototype.resize = function() {
    return null;
  };

  Radar.prototype.scaleSprites = function() {
    var i, tgtScale, _i, _ref;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      tgtScale = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      TweenMax.to(this.sprites[i].scale, 2, {
        x: tgtScale,
        y: tgtScale,
        ease: Bounce.easeOut
      });
    }
    return null;
  };

  Radar.prototype.createSprites = function() {
    var i, rot, rotInc, _i, _ref;
    rotInc = 360 / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.sprite.scale.x = this.sprite.scale.y = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      rot = (i * rotInc) * window.app.degToRad;
      this.sprite.position.x = this.midX + ((this.radarWidth / this.numSprites) * i);
      this.sprite.position.y = this.midY;
      this.holder.addChild(this.sprite);
      this.sprites.push(this.sprite);
    }
    return null;
  };

  return Radar;

})(Sketch);

Ribbon = (function(_super) {
  __extends(Ribbon, _super);

  function Ribbon(renderer) {
    this.renderer = renderer;
    this.drawRibbon = __bind(this.drawRibbon, this);
    this.updateTrails = __bind(this.updateTrails, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Ribbon.__super__.constructor.call(this, this.renderer);
  }

  Ribbon.prototype.load = function() {
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 2.9;
      this.baseNode.yIncrement = 3.7;
      this.baseNode.xOffset = 470;
      this.baseNode.yOffset = 220;
      this.ribbonWidth = 200;
      this.trailLength = 60;
      this.tailColour = 0xFFFFFF;
      this.nodeA = new Node(this.baseNode.position.x, this.baseNode.position.y - this.ribbonWidth);
      this.nodeB = new Node(this.baseNode.position.x, this.baseNode.position.y + this.ribbonWidth);
      this.nodeA.recordedPositions = this.nodeB.recordedPositions = this.trailLength;
      this.nodeA.fillPositions();
      this.nodeB.fillPositions();
      this.nodeA.sin = 0;
      this.nodeB.sin = 0;
      this.nodeA.inc = 4.6;
      this.nodeB.inc = 3.2;
      this.graphics = new PIXI.Graphics();
      this.tailA = [];
      this.tailB = [];
      this.stage.addChild(this.graphics);
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'ribbonWidth', 1, 200);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
      this.gui.add(this.nodeA, 'inc', 0.1, 359.9);
      this.gui.add(this.nodeB, 'inc', 0.1, 359.9);
    }
    this.view.appendChild(this.renderer.view);
    Ribbon.__super__.load.call(this);
    return null;
  };

  Ribbon.prototype.unload = function() {
    Ribbon.__super__.unload.call(this);
    return null;
  };

  Ribbon.prototype.update = function() {
    var ty;
    Ribbon.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(this.baseNode.xSin * window.app.degToRad) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(this.baseNode.ySin * window.app.degToRad) * this.baseNode.yOffset);
    this.nodeA.sin += this.nodeA.inc;
    this.nodeA.sin %= 360;
    ty = this.baseNode.position.y - (Math.sin(this.nodeA.sin * window.app.degToRad) * this.ribbonWidth);
    this.nodeA.moveTo(this.baseNode.position.x, ty);
    this.nodeB.sin += this.nodeB.inc;
    this.nodeB.sin %= 360;
    ty = this.baseNode.position.y + (Math.sin(this.nodeB.sin * window.app.degToRad) * this.ribbonWidth);
    this.nodeB.moveTo(this.baseNode.position.x, ty);
    this.drawRibbon();
    this.renderer.render(this.stage);
    return null;
  };

  Ribbon.prototype.resize = function() {
    return null;
  };

  Ribbon.prototype.updateTrails = function() {
    var i, sp, _i, _ref;
    for (i = _i = 0, _ref = this.trailLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      sp = this.tailA[i];
      sp.position.x = this.nodeA.positions[i].x;
      sp.position.y = this.nodeA.positions[i].y;
      sp = this.tailB[i];
      sp.position.x = this.nodeB.positions[i].x;
      sp.position.y = this.nodeB.positions[i].y;
    }
    return null;
  };

  Ribbon.prototype.drawRibbon = function() {
    var i, inc, pt1, pt2, pt3, pt4, _i, _ref;
    this.graphics.clear();
    inc = 1 / this.trailLength;
    for (i = _i = 0, _ref = this.trailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      pt1 = this.nodeA.positions[i];
      pt2 = this.nodeB.positions[i];
      pt3 = this.nodeA.positions[i + 1];
      pt4 = this.nodeB.positions[i + 1];
      this.graphics.beginFill(this.tailColour, i * inc);
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt3.x, pt3.y);
      this.graphics.lineTo(pt4.x, pt4.y);
      this.graphics.lineTo(pt2.x, pt2.y);
      this.graphics.endFill();
    }
    return null;
  };

  return Ribbon;

})(Sketch);

MathUtils = (function() {
  function MathUtils() {}

  MathUtils.degToRadValue = Math.PI / 180;

  MathUtils.radToDegValue = 180 / Math.PI;

  MathUtils.twoPI = 2 * Math.PI;

  MathUtils.degToRad = function(val) {
    return val * MathUtils.degToRadValue;
  };

  MathUtils.radToDeg = function(val) {
    return val * MathUtils.radToDegValue;
  };

  return MathUtils;

})();

ShapeShifter = (function(_super) {
  __extends(ShapeShifter, _super);

  function ShapeShifter(renderer) {
    this.renderer = renderer;
    this.placeNodes = __bind(this.placeNodes, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    ShapeShifter.__super__.constructor.call(this, this.renderer);
  }

  ShapeShifter.prototype.load = function() {
    var key, node, _ref;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.holder = new PIXI.DisplayObjectContainer();
      this.holder.position.x = window.innerWidth * 0.5;
      this.holder.position.y = window.innerHeight * 0.5;
      this.stage.addChild(this.holder);
      this.shapes = ['cube', 'cylinder', 'torus'];
      this.curShape = 0;
      this.size = 10;
      this.spacing = 32;
      this.xOffset = 0;
      this.yOffset = 0;
      this.depthOn = true;
      this.numNodes = this.size * this.size * this.size;
      this.nodes = this.createNodes();
      this.sprites = this.createSprites();
      this.placeSprites();
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'depthOn');
    }
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      node.position.x = node.position.y = node.position.z = 0;
    }
    this.view.appendChild(this.renderer.view);
    TweenMax.to(this, 0.75, {
      onComplete: this.placeNodes
    });
    ShapeShifter.__super__.load.call(this);
    return null;
  };

  ShapeShifter.prototype.unload = function() {
    ShapeShifter.__super__.unload.call(this);
    return null;
  };

  ShapeShifter.prototype.update = function() {
    var h, hh, hw, w;
    ShapeShifter.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.mousePressed) {
      window.app.mousePressed = false;
      this.placeNodes();
    }
    w = window.innerWidth;
    h = window.innerHeight;
    hw = window.innerWidth * 0.5;
    hh = window.innerHeight * 0.5;
    this.xOffset = ((window.app.pointerPosition.x - hw) / w) * 360;
    this.yOffset = ((window.app.pointerPosition.y - hh) / h) * 360;
    this.placeSprites();
    this.renderer.render(this.stage);
    return null;
  };

  ShapeShifter.prototype.resize = function() {
    return null;
  };

  ShapeShifter.prototype.createNodes = function() {
    var halfSpace, i, n, nodes, x, y, z, _i, _ref;
    nodes = {};
    x = y = z = 0;
    halfSpace = (this.spacing * this.size) * 0.5;
    for (i = _i = 0, _ref = this.numNodes; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = new Node();
      nodes[x + '_' + y + '_' + z] = n;
      x++;
      if (x === this.size) {
        x = 0;
        y++;
        if (y === this.size) {
          y = 0;
          z++;
        }
      }
    }
    return nodes;
  };

  ShapeShifter.prototype.placeNodes = function() {
    var angle, ct, halfSpace, i, inc, incInc, node, outerAngle, outerRadius, radius, tubeAngle, tubeRadius, x, y, z, _i, _j, _k, _ref, _ref1, _ref2, _x, _y, _z;
    halfSpace = (this.spacing * this.size) * 0.5;
    i = 0;
    inc = 360 / this.size;
    incInc = 360 / (this.size * this.size);
    for (x = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      for (y = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        for (z = _k = 0, _ref2 = this.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
          node = this.nodes[x + '_' + y + '_' + z];
          if (this.shapes[this.curShape] === 'cube') {
            _x = (x * this.spacing) - halfSpace;
            _y = (y * this.spacing) - halfSpace;
            _z = (z * this.spacing) - halfSpace;
          } else if (this.shapes[this.curShape] === 'cylinder') {
            ct = (this.size * x) + y;
            angle = MathUtils.degToRad(ct * incInc);
            radius = halfSpace * (z / this.size);
            _x = Math.cos(angle) * radius;
            _y = (y * this.spacing) - halfSpace;
            _z = Math.sin(angle) * radius;
          } else if (this.shapes[this.curShape] === 'torus') {
            ct = (this.size * x) + y;
            outerAngle = MathUtils.degToRad(ct * incInc);
            if (x === this.size - 1) {
              console.log(MathUtils.radToDeg(outerAngle));
            }
            tubeAngle = MathUtils.degToRad(z * inc);
            outerRadius = 128;
            tubeRadius = 64;
            _x = (outerRadius + (tubeRadius * Math.cos(tubeAngle))) * Math.cos(outerAngle);
            _z = (outerRadius + (tubeRadius * Math.cos(tubeAngle))) * Math.sin(outerAngle);
            _y = Math.sin(tubeAngle) * tubeRadius;
          }
          TweenMax.killTweensOf(node.position);
          TweenMax.to(node.position, 1.5, {
            x: _x,
            y: _y,
            z: _z,
            ease: Elastic.easeOut,
            delay: Math.random() * 0.2
          });
          i++;
        }
      }
    }
    this.curShape++;
    if (this.curShape === this.shapes.length) {
      this.curShape = 0;
    }
    return null;
  };

  ShapeShifter.prototype.createSprites = function() {
    var i, sp, sprites, _i, _ref;
    sprites = [];
    for (i = _i = 0, _ref = this.numNodes; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      sp = new PIXI.Sprite(window.app.textures[0]);
      sp.pivot.x = sp.pivot.y = 16;
      this.holder.addChild(sp);
      sprites.push(sp);
    }
    return sprites;
  };

  ShapeShifter.prototype.placeSprites = function() {
    var i, max, min, node, scalar, sp, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
    i = 0;
    min = Math.log(0.1);
    max = Math.log(1);
    for (x = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      for (y = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        for (z = _k = 0, _ref2 = this.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
          sp = this.sprites[i];
          node = this.nodes[x + '_' + y + '_' + z];
          scalar = this.depthOn ? node.position.z / (this.spacing * this.size) : 0;
          sp.scale.x = sp.scale.y = 1 + Math.exp(min + scalar);
          sp.position.x = (node.position.x * sp.scale.x) + (scalar * this.xOffset);
          sp.position.y = (node.position.y * sp.scale.y) + (scalar * this.yOffset);
          sp.alpha = 0.4;
          i++;
        }
      }
    }
    return null;
  };

  return ShapeShifter;

})(Sketch);

SineWave = (function(_super) {
  __extends(SineWave, _super);

  SineWave.id = 'Sine Wave';

  SineWave.prototype.phase = 0;

  SineWave.prototype.limit = 360;

  SineWave.prototype.waveLength = 203;

  SineWave.prototype.amplitude = 260;

  SineWave.prototype.frequency = 10;

  SineWave.prototype.rotateAngle = 0;

  SineWave.prototype.rotateSpeed = 351.16;

  SineWave.prototype.numSprites = 100;

  SineWave.prototype.midY = 0;

  SineWave.prototype.sprites = [];

  function SineWave(renderer) {
    this.renderer = renderer;
    this.createSprites = __bind(this.createSprites, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    SineWave.__super__.constructor.call(this, this.renderer);
  }

  SineWave.prototype.load = function() {
    this.midY = window.innerHeight * 0.5;
    this.midX = window.innerWidth * 0.5;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'waveLength', 10, 1000);
      this.gui.add(this, 'amplitude', 10, 500);
      this.gui.add(this, 'frequency', 1, 100);
      this.gui.add(this, 'limit', 1, 360);
      this.gui.add(this, 'rotateSpeed', 0, 720);
      this.gui.close();
    }
    this.view.appendChild(this.renderer.view);
    SineWave.__super__.load.call(this);
    return null;
  };

  SineWave.prototype.unload = function() {
    SineWave.__super__.unload.call(this);
    return null;
  };

  SineWave.prototype.update = function() {
    var angle, i, newx, newy, sp, spacing, xCalc, xPos, xSin, yCalc, yPos, _i, _ref;
    SineWave.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = this.sprites[i];
      xPos = (i * spacing) + ((this.phase / 360) * this.waveLength);
      xSin = ((xPos % this.waveLength) / this.waveLength) * 360;
      yPos = this.midY + (Math.sin(MathUtils.degToRad(xSin)) * this.amplitude);
      xCalc = xPos - this.midX;
      yCalc = yPos - this.midY;
      angle = MathUtils.degToRad(this.rotateAngle);
      newx = (xCalc * Math.cos(angle)) - (yCalc * Math.sin(angle));
      newy = (xCalc * Math.sin(angle)) + (yCalc * Math.cos(angle));
      sp.position.x = this.midX + newx;
      sp.position.y = this.midY + newy;
    }
    this.phase += this.frequency;
    this.phase %= this.limit;
    this.rotateAngle += this.rotateSpeed;
    this.rotateAngle %= 360;
    this.renderer.render(this.stage);
    return null;
  };

  SineWave.prototype.createSprites = function() {
    var i, sp, spacing, _i, _ref;
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(window.app.textures[0]);
      sp.pivot.x = sp.pivot.y = 16;
      sp.position.x = i * spacing;
      sp.position.y = this.midY;
      this.sprites.push(sp);
      this.stage.addChild(sp);
    }
    return null;
  };

  return SineWave;

})(Sketch);

Plankton = (function(_super) {
  __extends(Plankton, _super);

  function Plankton() {
    this.drawLimbs = __bind(this.drawLimbs, this);
    this.newDirection = __bind(this.newDirection, this);
    this.updateTail = __bind(this.updateTail, this);
    this.update = __bind(this.update, this);
    var hex, hsb;
    Plankton.__super__.constructor.call(this, Math.random() * window.innerWidth, Math.random() * window.innerHeight, 0);
    console.log('NEW Plankton : ' + this.position.x + ', ' + this.position.y);
    this.view = new PIXI.DisplayObjectContainer();
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.gut = new PIXI.Sprite(window.app.textures[0]);
    this.gut.pivot.x = this.gut.pivot.y = 16;
    hsb = [Math.random() * 360, 100, 100];
    hex = ColourConversion.hsbToHex(hsb);
    this.gut.tint = hex;
    this.view.addChild(this.gut);
    this.angle = 0;
    this.newDirection();
    this.tailProps = {
      min: 18,
      max: 32,
      dir: -1,
      dist: 0
    };
    this.tailProps.dist = this.tailProps.min + (Math.random() * (this.tailProps.max - this.tailProps.min));
    this.tailProps.inSpeed = 0.95 + (Math.random() * 0.04);
    this.tailProps.outSpeed = 1.05 + (Math.random() * 0.14);
    this.tailProps.accel = 0.7 + (Math.random() * 1);
    this.tailProps.decel = 0.85 + (Math.random() * 0.1);
    this.view.scale.x = this.view.scale.y = this.tailProps.decel;
    this.tail = new PIXI.Sprite(window.app.textures[0]);
    this.tail.pivot.x = this.tail.pivot.y = 16;
    this.tail.scale.x = this.tail.scale.y = 0.5;
    this.tail.position.y = this.tailProps.dist;
    this.view.addChild(this.tail);
    this.tailRight = new PIXI.Sprite(window.app.textures[0]);
    this.tailRight.pivot.x = this.tailRight.pivot.y = 16;
    this.tailRight.scale.x = this.tailRight.scale.y = 0.25;
    this.tailRight.position.y = this.tailProps.dist;
    this.tailRight.position.x = this.tailProps.dist;
    this.view.addChild(this.tailRight);
    this.tailLeft = new PIXI.Sprite(window.app.textures[0]);
    this.tailLeft.pivot.x = this.tailLeft.pivot.y = 16;
    this.tailLeft.scale.x = this.tailLeft.scale.y = 0.25;
    this.tailLeft.position.y = this.tailProps.dist;
    this.tailLeft.position.x = -this.tailProps.dist;
    this.view.addChild(this.tailLeft);
  }

  Plankton.prototype.update = function() {
    var cos, sin, vx, vy;
    this.graphics.clear();
    this.updateTail();
    this.drawLimbs();
    if (this.tailProps.dir === 1) {
      sin = Math.sin(MathUtils.degToRad(this.angle));
      cos = Math.cos(MathUtils.degToRad(this.angle));
      vx = (-sin * 1) * this.tailProps.accel;
      vy = (cos * 1) * this.tailProps.accel;
      this.velocity.x += vx;
      this.velocity.y += vy;
    } else {
      this.velocity.x *= this.tailProps.decel;
      this.velocity.y *= this.tailProps.decel;
    }
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
    if (this.position.y < -100) {
      this.position.y += window.innerHeight + 200;
    } else if (this.position.y > window.innerHeight + 100) {
      this.position.y -= window.innerHeight + 200;
    }
    if (this.position.x < -100) {
      this.position.x += window.innerWidth + 200;
    } else if (this.position.x > window.innerWidth + 100) {
      this.position.x -= window.innerWidth + 200;
    }
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.view.rotation = MathUtils.degToRad(this.angle + 180);
    return null;
  };

  Plankton.prototype.updateTail = function() {
    var cos, nx, ny, sin;
    if (this.tailProps.dir === -1) {
      this.tailProps.dist *= this.tailProps.inSpeed;
      if (this.tailProps.dist < this.tailProps.min) {
        this.tailProps.dir *= -1;
      }
    } else {
      this.tailProps.dist *= this.tailProps.outSpeed;
      if (this.tailProps.dist > this.tailProps.max) {
        this.tailProps.dir *= -1;
      }
    }
    this.tail.position.y = this.tailProps.dist;
    sin = Math.sin(MathUtils.degToRad(30));
    cos = Math.cos(MathUtils.degToRad(30));
    nx = -sin * this.tailProps.dist;
    ny = cos * this.tailProps.dist;
    this.tailLeft.position.x = nx;
    this.tailLeft.position.y = ny;
    sin = Math.sin(MathUtils.degToRad(-30));
    cos = Math.cos(MathUtils.degToRad(-30));
    nx = -sin * this.tailProps.dist;
    ny = cos * this.tailProps.dist;
    this.tailRight.position.x = nx;
    this.tailRight.position.y = ny;
    return null;
  };

  Plankton.prototype.newDirection = function() {
    var newAngle, time,
      _this = this;
    TweenMax.killTweensOf(this);
    newAngle = Math.random() * 360;
    time = 0.5 + (3 * Math.random());
    TweenMax.to(this, time, {
      angle: newAngle,
      onComplete: function() {
        return _this.newDirection();
      }
    });
    return null;
  };

  Plankton.prototype.drawLimbs = function() {
    this.graphics.lineStyle(1, 0xFFd0d0, 0.9);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tail.position.x, this.tail.position.y);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tailRight.position.x, this.tailRight.position.y);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tailLeft.position.x, this.tailLeft.position.y);
    return null;
  };

  return Plankton;

})(Node);

Point = (function() {
  function Point(x, y, z) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    this.z = z != null ? z : 0;
    this.toString = __bind(this.toString, this);
    this.clone = __bind(this.clone, this);
  }

  Point.prototype.clone = function() {
    return new Point(this.x, this.y, this.z);
  };

  Point.prototype.toString = function() {
    return 'Point [x:' + this.x + ', y:' + this.y + ', z:' + this.z + ']';
  };

  return Point;

})();

SpirographNode = (function(_super) {
  __extends(SpirographNode, _super);

  function SpirographNode(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.drawTrails = __bind(this.drawTrails, this);
    this.updateTint = __bind(this.updateTint, this);
    this.update = __bind(this.update, this);
    this.randomise = __bind(this.randomise, this);
    SpirographNode.__super__.constructor.call(this, x, y, z);
    this.midX = window.innerWidth * 0.5;
    this.midY = window.innerHeight * 0.5;
    this.sin = 0;
    this.speed = 1;
    this.radSin = 0;
    this.radSpeed = 10;
    this.radMin = 180;
    this.radMax = 260;
    this.tailWidth = 3;
    this.color = 120;
    this.colorSpeed = 0;
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.recordedPositions = 90;
    this.positions = [];
    this.fillPositions();
    this.view = new PIXI.DisplayObjectContainer;
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.randomSpeeds = [0.1, 1.1, 59.9, 60.4, 120.1, 180.6, 240.2, 300.1, 75.5, 25.2];
    this.randomSmallRads = [0, 30, 60, 180, 90, 45, 40, 75, 130, 140, 150, 160];
    this.randomBigRads = [227, 240, 300, 248, 200, 187, 210, 195, 320, 305, 310];
  }

  SpirographNode.prototype.randomise = function() {
    var r1, r2, s1, s2;
    s1 = this.randomSpeeds[Math.floor(Math.random() * this.randomSpeeds.length)];
    s2 = this.randomSpeeds[Math.floor(Math.random() * this.randomSpeeds.length)];
    r1 = this.randomSmallRads[Math.floor(Math.random() * this.randomSmallRads.length)];
    r2 = this.randomBigRads[Math.floor(Math.random() * this.randomBigRads.length)];
    TweenMax.to(this, 1.5, {
      radMin: r1,
      radMax: r2,
      speed: s1,
      radSpeed: s2,
      colorSpeed: Math.random()
    });
    return null;
  };

  SpirographNode.prototype.update = function() {
    var radius, x, y;
    this.radSin += this.radSpeed;
    this.radSin %= 360;
    radius = this.radMin + (Math.sin(MathUtils.degToRad(this.radSin)) * (this.radMax - this.radMin));
    this.sin += this.speed;
    this.sin %= 360;
    x = -Math.sin(MathUtils.degToRad(this.sin)) * radius;
    y = Math.cos(MathUtils.degToRad(this.sin)) * radius;
    this.moveTo(x + this.midX, y + this.midY, 0);
    this.color += this.colorSpeed;
    this.color %= 360;
    this.drawTrails();
    return null;
  };

  SpirographNode.prototype.updateTint = function() {
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    return null;
  };

  SpirographNode.prototype.drawTrails = function() {
    var i, inc, ptA, ptB, tInc, _i, _ref;
    this.graphics.clear();
    inc = 1 / this.recordedPositions;
    tInc = this.tailWidth / this.recordedPositions;
    ptA = this.positions[0];
    ptB = null;
    for (i = _i = 0, _ref = this.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = this.positions[i];
      ptB = this.positions[i + 1];
      this.hsb = [this.color, 100, 100];
      this.hex = ColourConversion.hsbToHex(this.hsb);
      this.graphics.lineStyle(i * tInc, this.hex, i * inc);
      this.graphics.moveTo(ptA.x, ptA.y);
      this.graphics.lineTo(ptB.x, ptB.y);
    }
    return null;
  };

  return SpirographNode;

})(Node);

SquidNode = (function(_super) {
  __extends(SquidNode, _super);

  function SquidNode(x_, y_, z_) {
    var i, n, _i;
    if (x_ == null) {
      x_ = 0;
    }
    if (y_ == null) {
      y_ = 0;
    }
    if (z_ == null) {
      z_ = 0;
    }
    this.drawNodePath = __bind(this.drawNodePath, this);
    this.update = __bind(this.update, this);
    this.setTailColor = __bind(this.setTailColor, this);
    this.setColor = __bind(this.setColor, this);
    SquidNode.__super__.constructor.call(this, 0, 0, z_);
    this.basePosition = {
      x: x_,
      y: y_
    };
    this.color = 0;
    this.tailColor = 0;
    this.view = new PIXI.DisplayObjectContainer();
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.head = new PIXI.Sprite(window.app.textures[0]);
    this.head.pivot.x = this.head.pivot.y = 16;
    this.view.addChild(this.head);
    this.setColor(this.color);
    this.tailWidth = 3;
    this.tailSpread = 40;
    this.recordedPositions = 120;
    this.positions = [];
    this.firstUpdate = true;
    this.nodes = [];
    for (i = _i = 0; _i < 5; i = ++_i) {
      n = new Node();
      n.recordedPositions = this.recordedPositions;
      n.fillPositions();
      n.sin = Math.random() * 360;
      n.inc = 2 + (3 * Math.random());
      this.nodes.push(n);
    }
    /*
    		make it spin
    		around it's position
    */

    this.sin = 0;
    this.speed = 1;
    this.radSin = 0;
    this.radSpeed = 5;
    this.radMin = 200;
    this.radMax = 240;
  }

  SquidNode.prototype.setColor = function(value) {
    this.color = value;
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.head.tint = this.hex;
    return null;
  };

  SquidNode.prototype.setTailColor = function(value) {
    this.tailColor = value;
    return null;
  };

  SquidNode.prototype.update = function() {
    var alphaInc, ang, i, node, nx, ny, pcos, psin, ptA, ptB, radius, widthInc, x, xdif, y, ydif, _i, _j, _len, _ref, _ref1;
    this.sin += this.speed;
    this.sin %= 360;
    this.radSin += this.radSpeed;
    this.radSin %= 360;
    psin = Math.sin(MathUtils.degToRad(this.sin));
    pcos = Math.cos(MathUtils.degToRad(this.sin));
    radius = this.radMin + (Math.sin(MathUtils.degToRad(this.radSin)) * (this.radMax - this.radMin));
    x = -psin * radius;
    y = pcos * radius;
    this.moveTo(this.basePosition.x + x, this.basePosition.y + y);
    if (this.firstUpdate) {
      this.fillPositions();
      this.firstUpdate = false;
    }
    this.head.position.x = this.position.x;
    this.head.position.y = this.position.y;
    alphaInc = 1 / this.recordedPositions;
    widthInc = this.tailWidth / this.recordedPositions;
    this.graphics.clear();
    for (i = _i = 0, _ref = this.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = this.positions[i];
      ptB = this.positions[i + 1];
      this.graphics.lineStyle(i * widthInc, this.hex, i * alphaInc);
      this.graphics.moveTo(ptA.x, ptA.y);
      this.graphics.lineTo(ptB.x, ptB.y);
    }
    _ref1 = this.nodes;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      node = _ref1[_j];
      node.sin += node.inc;
      node.sin %= 360;
      x = 0;
      y = Math.sin(MathUtils.degToRad(node.sin)) * this.tailSpread;
      xdif = this.positions[this.recordedPositions - 2].x - this.positions[this.recordedPositions - 1].x;
      ydif = this.positions[this.recordedPositions - 2].y - this.positions[this.recordedPositions - 1].y;
      ang = Math.atan2(ydif, xdif);
      nx = -Math.sin(ang) * y;
      ny = Math.cos(ang) * y;
      node.moveTo(nx, ny);
      this.drawNodePath(node);
    }
    return null;
  };

  SquidNode.prototype.drawNodePath = function(node) {
    var alphaInc, i, oA, oB, ptA, ptB, scale, widthInc, _i, _ref;
    alphaInc = 1 / this.recordedPositions;
    widthInc = this.tailWidth / this.recordedPositions;
    scale = 1;
    for (i = _i = 0, _ref = node.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = node.positions[i];
      ptB = node.positions[i + 1];
      oA = this.positions[i];
      oB = this.positions[i + 1];
      scale = 1 - (i / this.recordedPositions);
      this.graphics.lineStyle(i * widthInc, this.hex, i * alphaInc);
      this.graphics.moveTo(oA.x + (ptA.x * scale), oA.y + (ptA.y * scale));
      this.graphics.lineTo(oB.x + (ptB.x * scale), oB.y + (ptB.y * scale));
    }
    return null;
  };

  return SquidNode;

})(Node);

Smoky = (function(_super) {
  __extends(Smoky, _super);

  Smoky.id = 'Smoky';

  Smoky.prototype.numNodes = 200;

  Smoky.prototype.checkDist = 100;

  Smoky.prototype.checkDistSq = 0;

  Smoky.prototype.nodes = [];

  Smoky.prototype.sprites = [];

  function Smoky(renderer) {
    this.renderer = renderer;
    this.mouseMove = __bind(this.mouseMove, this);
    this.update = __bind(this.update, this);
    this.resize = __bind(this.resize, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.checkDistSq = this.checkDist * this.checkDist;
    Smoky.__super__.constructor.call(this, this.renderer);
  }

  Smoky.prototype.load = function() {
    if (this.loaded) {
      this.windowWidth = window.innerWidth;
      this.windowHeight = window.innerHeight;
      this.areaWidth = this.windowWidth + 400;
      this.areaHeight = this.windowHeight + 400;
      this.view.appendChild(this.renderer.view);
      Smoky.__super__.load.call(this);
      return;
    }
    this.windowWidth = window.innerWidth;
    this.windowHeight = window.innerHeight;
    this.areaWidth = this.windowWidth + 400;
    this.areaHeight = this.windowHeight + 400;
    this.stage = new PIXI.Stage(window.app.stageColor);
    this.view = document.createElement('div');
    this.view.appendChild(this.renderer.view);
    this.createNodes();
    this.createSprites();
    return Smoky.__super__.load.call(this);
  };

  Smoky.prototype.unload = function() {
    Smoky.__super__.unload.call(this);
    return null;
  };

  Smoky.prototype.resize = function() {
    return null;
  };

  Smoky.prototype.createNodes = function() {
    var i, n, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      n = new Node(Math.random() * this.windowWidth, Math.random() * this.windowHeight);
      n.velocity.x = 3 - (6 * Math.random());
      n.velocity.y = 3 - (6 * Math.random());
      n.sinPos = Math.random() * 360;
      n.sinIncrement = Math.random() * 0.5;
      n.scaleAmount = Math.random() * 2;
      this.nodes.push(n);
    }
    return null;
  };

  Smoky.prototype.createSprites = function() {
    var i, sp, _i, _ref;
    this.tex = window.app.textures[0];
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(this.tex);
      sp.pivot.x = 16;
      sp.pivot.y = 16;
      sp.blendMode = PIXI.blendModes.SCREEN;
      sp.alpha = 0.1 + (Math.random() * 0.2);
      this.sprites.push(sp);
      this.stage.addChild(sp);
    }
    return null;
  };

  Smoky.prototype.updateSprites = function() {
    var distTo, i, node, sp, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      node = this.nodes[i];
      node.position.x += node.velocity.x;
      node.position.y += node.velocity.y;
      node.sinPos += node.sinIncrement;
      node.sinPos %= 360;
      node.scale = 10 + (Math.sin(node.sinPos * (Math.PI / 180)) * node.scaleAmount);
      if (node.position.x > this.windowWidth + 200) {
        node.position.x -= this.areaWidth;
      } else if (node.position.x < -200) {
        node.position.x += this.areaWidth;
      }
      if (node.position.y > this.windowHeight + 200) {
        node.position.y -= this.areaHeight;
      } else if (node.position.y < -200) {
        node.position.y += this.areaHeight;
      }
      distTo = this.distanceTo({
        x: node.position.x,
        y: node.position.y
      }, {
        x: this.curX,
        y: this.curY
      });
      if (distTo.dist < this.checkDistSq) {
        node.velocity.x = ((distTo.xDif * -1) / this.checkDist) * 5;
        node.velocity.y = ((distTo.yDif * -1) / this.checkDist) * 5;
      }
      sp = this.sprites[i];
      sp.position.x = node.position.x;
      sp.position.y = node.position.y;
      sp.scale.x = sp.scale.y = node.scale;
    }
    return null;
  };

  Smoky.prototype.distanceTo = function(object, target) {
    var xDif, yDif;
    xDif = target.x - object.x;
    yDif = target.y - object.y;
    return {
      xDif: xDif,
      yDif: yDif,
      dist: (xDif * xDif) + (yDif * yDif)
    };
  };

  Smoky.prototype.update = function() {
    Smoky.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.curX = window.app.pointerPosition.x;
    this.curY = window.app.pointerPosition.y;
    this.updateSprites();
    this.renderer.render(this.stage);
    return null;
  };

  Smoky.prototype.mouseMove = function(e) {
    this.curX = e.pageX;
    this.curY = e.pageY;
    return null;
  };

  return Smoky;

})(Sketch);

Spirals = (function(_super) {
  __extends(Spirals, _super);

  Spirals.id = 'Spirals';

  Spirals.prototype.midPoint = null;

  Spirals.prototype.nodes = [];

  Spirals.prototype.deadNodes = [];

  Spirals.prototype.newNodeCount = 1;

  Spirals.prototype.newNodeLimit = 10;

  Spirals.prototype.changeCount = 720;

  Spirals.prototype.changeLimit = 720;

  Spirals.prototype.rotateSpeed = 11;

  Spirals.prototype.moveSpeed = 0.6;

  Spirals.prototype.sqDist = 100;

  function Spirals(renderer) {
    this.renderer = renderer;
    this.createSprite = __bind(this.createSprite, this);
    this.createNode = __bind(this.createNode, this);
    this.distToMidpoint = __bind(this.distToMidpoint, this);
    this.updateNodes = __bind(this.updateNodes, this);
    this.randomisePattern = __bind(this.randomisePattern, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Spirals.__super__.constructor.call(this, this.renderer);
  }

  Spirals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'rotateSpeed', -50, 50).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.add(this, 'moveSpeed', 0.1, 10).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.close();
    }
    this.midPoint = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5
    };
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    this.view.appendChild(this.renderer.view);
    this.randomisePattern();
    Spirals.__super__.load.call(this);
    return null;
  };

  Spirals.prototype.unload = function() {
    Spirals.__super__.unload.call(this);
    return null;
  };

  Spirals.prototype.update = function() {
    var newNode;
    Spirals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.spacePressed) {
      this.changeCount = this.changeLimit;
      window.app.spacePressed = false;
      this.randomisePattern();
    }
    this.newNodeCount--;
    if (this.newNodeCount === 0) {
      this.newNodeCount = this.newNodeLimit;
      newNode = this.createNode();
      this.nodes.push(newNode);
      this.stage.addChild(newNode.sprite);
    }
    this.changeCount--;
    if (this.changeCount === 0) {
      this.randomisePattern();
      this.changeCount = this.changeLimit;
    }
    this.updateNodes();
    this.renderer.render(this.stage);
    return null;
  };

  Spirals.prototype.resize = function() {
    if (this.midPoint !== null) {
      this.midPoint.x = window.innerWidth * 0.5;
      this.midPoint.y = window.innerHeight * 0.5;
    }
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    return null;
  };

  Spirals.prototype.randomisePattern = function() {
    TweenMax.to(this, 0.5, {
      rotateSpeed: -50 + (Math.random() * 100),
      ease: Power4.easeOut
    });
    TweenMax.to(this, 0.5, {
      moveSpeed: Math.random() * 3,
      ease: Power4.easeOut
    });
    return null;
  };

  Spirals.prototype.updateNodes = function() {
    var angle, i, newx, newy, node, _i, _ref;
    for (i = _i = _ref = this.nodes.length - 1; _i >= 0; i = _i += -1) {
      node = this.nodes[i];
      node.y += this.moveSpeed;
      angle = MathUtils.degToRad(node.phase);
      newx = -node.y * Math.sin(angle);
      newy = node.y * Math.cos(angle);
      node.sprite.position.x = this.midPoint.x + newx;
      node.sprite.position.y = this.midPoint.y + newy;
      node.phase += this.rotateSpeed;
      node.phase %= 360;
      node.sprite.scale.x = node.sprite.scale.y = 0.25 + ((this.distToMidpoint(node) / this.sqDist) * 4);
      if ((newx - (16 * 5) + this.midPoint.x) > window.innerWidth) {
        this.stage.removeChild(node.sprite);
        this.nodes.splice(i, 1);
        this.deadNodes.push(node);
      }
    }
    return null;
  };

  Spirals.prototype.distToMidpoint = function(node) {
    var xDif, yDif;
    xDif = this.midPoint.x - node.sprite.position.x;
    yDif = this.midPoint.y - node.sprite.position.y;
    return (xDif * xDif) + (yDif * yDif);
  };

  Spirals.prototype.createNode = function() {
    var node;
    if (this.deadNodes.length === 0) {
      node = {
        y: 0,
        x: 0,
        sprite: this.createSprite(),
        phase: 0
      };
    } else {
      node = this.deadNodes[0];
      this.deadNodes.splice(0, 1);
      node.y = 0;
      node.x = 0;
      node.phase = 0;
    }
    return node;
  };

  Spirals.prototype.createSprite = function() {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = 16;
    sp.pivot.y = 16;
    return sp;
  };

  return Spirals;

})(Sketch);

Spirograph = (function(_super) {
  __extends(Spirograph, _super);

  function Spirograph(renderer) {
    this.renderer = renderer;
    this.addNode = __bind(this.addNode, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Spirograph.__super__.constructor.call(this, this.renderer);
  }

  Spirograph.prototype.load = function() {
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.nodes = [];
      this.addNode();
      this.addNode();
      this.addNode();
    }
    this.view.appendChild(this.renderer.view);
    Spirograph.__super__.load.call(this);
    return null;
  };

  Spirograph.prototype.unload = function() {
    Spirograph.__super__.unload.call(this);
    return null;
  };

  Spirograph.prototype.update = function() {
    var node, _i, _len, _ref;
    Spirograph.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.update();
    }
    this.renderer.render(this.stage);
    return null;
  };

  Spirograph.prototype.resize = function() {
    return null;
  };

  Spirograph.prototype.addNode = function() {
    var folder, node;
    node = new SpirographNode();
    this.nodes.push(node);
    node.color = Math.random() * 360;
    node.updateTint();
    this.stage.addChild(node.view);
    if (this.nodes.length === 1) {
      node.speed = 59.9;
      node.radSpeed = 122;
    } else if (this.nodes.length === 2) {
      node.speed = 60;
      node.radSpeed = 61;
    } else if (this.nodes.length === 3) {
      node.speed = 60;
      node.radSpeed = 119;
    }
    node.colorSpeed = Math.random();
    folder = this.gui.addFolder('Spirograph ' + this.nodes.length);
    folder.add(node, 'speed', 0.1, 359.9).listen();
    folder.add(node, 'radSpeed', 0.1, 359.9).listen();
    folder.add(node, 'radMin', 0.1, 500).listen();
    folder.add(node, 'radMax', 0.1, 500).listen();
    folder.add(node, 'tailWidth', 1, 30);
    folder.add(node, 'color', 0, 360.0);
    folder.add(node, 'colorSpeed', 0, 1).listen();
    folder.add(node, 'recordedPositions', 1, 360);
    folder.add(node, 'randomise');
    return null;
  };

  return Spirograph;

})(Sketch);

Squids = (function(_super) {
  __extends(Squids, _super);

  function Squids(renderer) {
    this.renderer = renderer;
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.random2 = __bind(this.random2, this);
    this.random1 = __bind(this.random1, this);
    this.random0 = __bind(this.random0, this);
    this.load = __bind(this.load, this);
    Squids.__super__.constructor.call(this, this.renderer);
  }

  Squids.prototype.load = function() {
    var col, i, squid, _i;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.squids = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        squid = new SquidNode(window.innerWidth * ((1 / 4) * (i + 1)), window.innerHeight * 0.5);
        squid.speed = 1 + (Math.random() * 5);
        squid.radSpeed = 1 + (Math.random() * 36);
        col = Math.random() * 360;
        squid.setColor(col);
        squid.setTailColor(col);
        this.stage.addChild(squid.view);
        this.squids.push(squid);
      }
      this.gui.add(this, 'random0');
      this.gui.add(this, 'random1');
      this.gui.add(this, 'random2');
    }
    this.view.appendChild(this.renderer.view);
    Squids.__super__.load.call(this);
    return null;
  };

  Squids.prototype.random0 = function() {
    var col, squid;
    squid = this.squids[0];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.random1 = function() {
    var col, squid;
    squid = this.squids[1];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.random2 = function() {
    var col, squid;
    squid = this.squids[2];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.unload = function() {
    Squids.__super__.unload.call(this);
    return null;
  };

  Squids.prototype.update = function() {
    var squid, _i, _len, _ref;
    Squids.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.squids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      squid = _ref[_i];
      squid.update();
    }
    this.renderer.render(this.stage);
    return null;
  };

  Squids.prototype.resize = function() {
    return null;
  };

  return Squids;

})(Sketch);

Stacks = (function(_super) {
  __extends(Stacks, _super);

  Stacks.prototype.yCount = 30;

  Stacks.prototype.xCount = 40;

  Stacks.prototype.minSpeed = -40;

  Stacks.prototype.maxSpeed = 40;

  Stacks.prototype.tgtScale = 1;

  Stacks.prototype.nodes = [];

  Stacks.prototype.deadNodes = [];

  function Stacks(renderer) {
    this.renderer = renderer;
    this.randomiseSpeeds = __bind(this.randomiseSpeeds, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Stacks.__super__.constructor.call(this, this.renderer);
  }

  Stacks.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'minSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
      this.gui.add(this, 'maxSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
    }
    this.view.appendChild(this.renderer.view);
    Stacks.__super__.load.call(this);
    return null;
  };

  Stacks.prototype.unload = function() {
    Stacks.__super__.unload.call(this);
    return null;
  };

  Stacks.prototype.update = function() {
    Stacks.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.updateNodes();
    this.renderer.render(this.stage);
    return null;
  };

  Stacks.prototype.resize = function() {
    return null;
  };

  Stacks.prototype.updateNodes = function() {
    var i, j, newSpeed, node, totSpeed, winWidth, xdif, _i, _j, _ref, _ref1;
    winWidth = window.innerWidth;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        node = this.nodes[i][j];
        node.sprite.position.x += node.speed;
        if (node.sprite.position.x <= 0) {
          node.sprite.position.x = 0.1;
          node.speed *= -1;
        } else if (node.sprite.position.x >= winWidth) {
          node.sprite.position.x = winWidth - 0.1;
          node.speed *= -1;
        }
        if (this.nodes[i + 1]) {
          if (node.sprite.position.x >= this.nodes[i + 1][j].sprite.position.x - (16 * this.tgtScale)) {
            xdif = Math.abs(node.sprite.position.x - this.nodes[i + 1][j].sprite.position.x) - (16.2 * this.tgtScale);
            if (xdif < 0) {
              xdif *= -1;
            }
            newSpeed = this.nodes[i + 1][j].speed;
            totSpeed = newSpeed + node.speed;
            this.nodes[i + 1][j].speed = node.speed;
            node.speed = newSpeed;
            node.sprite.position.x -= xdif * 0.5;
            this.nodes[i + 1][j].sprite.position.x += xdif * 0.5;
            /*
            						ms 4
            						os 2
            						os / (ms + os)
            						2 / (4 + 2)
            */

          }
        }
      }
    }
    return null;
  };

  Stacks.prototype.createSprites = function() {
    var i, j, _i, _j, _ref, _ref1;
    this.tgtScale = (window.innerHeight / (this.yCount - 1)) / 30;
    this.nodes = [];
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.nodes[i] = [];
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j] = {
          sprite: this.addSprite(i, j),
          speed: 0
        };
      }
    }
    this.randomiseSpeeds();
    return null;
  };

  Stacks.prototype.addSprite = function(x, y) {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = sp.pivot.y = 16;
    sp.position.x = x * (window.innerWidth / this.xCount);
    sp.position.y = y * (30 * this.tgtScale);
    sp.scale.x = sp.scale.y = this.tgtScale;
    this.stage.addChild(sp);
    return sp;
  };

  Stacks.prototype.randomiseSpeeds = function() {
    var i, j, speedDif, _i, _j, _ref, _ref1;
    speedDif = this.maxSpeed - this.minSpeed;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j].speed = this.minSpeed + (Math.random() * speedDif);
      }
    }
    return null;
  };

  return Stacks;

})(Sketch);

Trails = (function(_super) {
  __extends(Trails, _super);

  Trails.id = 'Trails';

  Trails.prototype.trailLength = 70;

  Trails.prototype.sprites = [];

  Trails.prototype.positions = [];

  Trails.prototype.sinOffset = 0;

  Trails.prototype.sinIncrement = 0;

  Trails.prototype.maxScale = 4;

  Trails.prototype.minScale = 1;

  Trails.prototype.wobbleAngle = 17;

  function Trails(renderer) {
    this.renderer = renderer;
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Trails.__super__.constructor.call(this, this.renderer);
    this.toAdd = 0.00000000001;
    this.sinIncrement = MathUtils.twoPI / 18;
  }

  Trails.prototype.load = function() {
    var i, sp, _i, _ref,
      _this = this;
    if (this.loaded) {
      this.gui.domElement.style.display = 'block';
      this.gui.close();
      this.view.appendChild(this.renderer.view);
      Trails.__super__.load.call(this);
    } else {
      this.curX = this.mouseX = window.innerWidth * 0.5;
      this.curY = this.mouseY = window.innerHeight * 0.5;
      this.stage = new PIXI.Stage(window.app.stageColor);
      for (i = _i = 0, _ref = this.trailLength - 1; _i <= _ref; i = _i += 1) {
        sp = new PIXI.Sprite(window.app.textures[0]);
        sp.alpha = 0;
        sp.pivot.x = 16;
        sp.pivot.y = 16;
        this.stage.addChild(sp);
        this.sprites.push(sp);
      }
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'sinIncrement', 0, MathUtils.twoPI / 5);
      this.gui.add(this, 'wobbleAngle', 0, 90);
      this.gui.add(this, 'maxScale', 0, 10).listen().onChange(function() {
        if (_this.maxScale < _this.minScale) {
          return _this.minScale = _this.maxScale;
        }
      });
      this.gui.add(this, 'minScale', 0, 10).listen().onChange(function() {
        if (_this.minScale > _this.maxScale) {
          return _this.maxScale = _this.minScale;
        }
      });
      this.gui.close();
      Trails.__super__.load.call(this);
    }
    return null;
  };

  Trails.prototype.unload = function() {
    this.gui.domElement.style.display = 'none';
    Trails.__super__.unload.call(this);
    return null;
  };

  Trails.prototype.update = function() {
    var angle, dist, newX, newY, p, pos, vecX, vecY, _i, _len, _ref;
    Trails.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    angle = MathUtils.degToRad(Math.sin(this.sinOffset) * this.wobbleAngle);
    vecX = window.app.pointerPosition.x - this.curX;
    vecY = window.app.pointerPosition.y - this.curY;
    newX = (vecX * Math.cos(angle)) - (vecY * Math.sin(angle));
    newY = (vecX * Math.sin(angle)) + (vecY * Math.cos(angle));
    this.curX += newX / 100;
    this.curY += newY / 100;
    this.positions.push({
      x: this.curX,
      y: this.curY
    });
    if (this.positions.length > this.trailLength) {
      this.positions.splice(0, 1);
    }
    _ref = this.positions;
    for (p = _i = 0, _len = _ref.length; _i < _len; p = ++_i) {
      pos = _ref[p];
      this.sprites[p].scale.x = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].scale.y = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].position.x = pos.x;
      this.sprites[p].position.y = pos.y;
      this.sprites[p].alpha = p / this.trailLength;
    }
    this.renderer.render(this.stage);
    dist = Math.sqrt((vecX * vecX) + (vecY * vecY));
    if (dist === 0) {
      dist = 1;
    }
    this.toAdd = MathUtils.degToRad(30 / dist);
    this.sinOffset += this.sinIncrement + this.toAdd;
    this.sinOffset %= MathUtils.twoPI;
    return null;
  };

  return Trails;

})(Sketch);

InfoPanel = (function() {
  InfoPanel.prototype.view = null;

  InfoPanel.prototype.bg = null;

  InfoPanel.prototype.contentPanel = null;

  function InfoPanel() {
    this.resize = __bind(this.resize, this);
    this.bgClick = __bind(this.bgClick, this);
    this.hide = __bind(this.hide, this);
    this.show = __bind(this.show, this);
    this.view = $('#information-panel');
    this.bg = $('#information-panel-bg');
    this.contentPanel = $('#information-panel-content');
    document.getElementById('information-panel-bg').onclick = this.bgClick;
    $(this.bg).css('cursor', 'pointer');
    this.resize();
  }

  InfoPanel.prototype.show = function() {
    $(this.view).css('z-index', '2000');
    TweenMax.to(this.view, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  InfoPanel.prototype.hide = function() {
    var _this = this;
    TweenMax.to(this.view, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        return $(_this.view).css('z-index', '2');
      }
    });
    return null;
  };

  InfoPanel.prototype.bgClick = function() {
    window.app.handleInfoClick();
    return null;
  };

  InfoPanel.prototype.resize = function() {
    var xPos, yPos;
    xPos = (window.innerWidth - $(this.contentPanel).width()) * 0.5;
    yPos = (window.innerHeight - $(this.contentPanel).height()) * 0.5;
    console.log('RESIZING :: ' + xPos + ', ' + yPos);
    return null;
  };

  return InfoPanel;

})();

MenuButton = (function() {
  MenuButton.prototype.isActive = false;

  function MenuButton(title, id) {
    this.title = title;
    this.id = id;
    this.click = __bind(this.click, this);
    this.mouseout = __bind(this.mouseout, this);
    this.mouseover = __bind(this.mouseover, this);
    this.deselect = __bind(this.deselect, this);
    this.select = __bind(this.select, this);
    this.disable = __bind(this.disable, this);
    this.enable = __bind(this.enable, this);
    this.view = document.createElement('div');
    $(this.view).attr('class', 'menu-button-holder');
    this.view.innerHTML = "<p class='menu-button'>" + this.title + "</p>";
  }

  MenuButton.prototype.enable = function() {
    this.view.onmouseover = this.mouseover;
    this.view.onmouseout = this.mouseout;
    this.view.onclick = this.click;
    return null;
  };

  MenuButton.prototype.disable = function() {
    this.view.onmouseover = null;
    this.view.onmouseout = null;
    this.view.onclick = null;
    return null;
  };

  MenuButton.prototype.select = function() {
    this.mouseover();
    this.isActive = true;
    return null;
  };

  MenuButton.prototype.deselect = function() {
    this.isActive = false;
    this.mouseout();
    return null;
  };

  MenuButton.prototype.mouseover = function() {
    if (this.isActive) {
      return;
    }
    TweenMax.to(this.view, 0.3, {
      css: {
        color: 'rgb(255, 0, 61)',
        background: 'rgba(0,0,0,0.55)'
      }
    });
    return null;
  };

  MenuButton.prototype.mouseout = function() {
    if (this.isActive) {
      return;
    }
    TweenMax.to(this.view, 2, {
      css: {
        color: '#dedede',
        background: 'rgba(0,0,0,0)'
      }
    });
    return null;
  };

  MenuButton.prototype.click = function() {
    window.app.selectSketch(this.id);
    return null;
  };

  return MenuButton;

})();

Menu = (function() {
  Menu.prototype.buttons = [];

  function Menu(app, data) {
    this.app = app;
    this.data = data;
    this.handleDivOut = __bind(this.handleDivOut, this);
    this.handleDivOver = __bind(this.handleDivOver, this);
    this.disable = __bind(this.disable, this);
    this.enable = __bind(this.enable, this);
    this.menuPanel = document.getElementById('menu-panel');
    this.menuButtons = document.getElementById('menu-buttons');
    this.currentButton = document.getElementById('current-sketch');
    this.createButtons();
    $(this.currentButton).css('cursor', 'pointer');
    this.currentButton.onclick = this.app.handleMenuClick;
    this.buttons[this.app.currentSketch].select();
  }

  Menu.prototype.show = function() {
    $(this.menuPanel).css('z-index', '1200');
    TweenMax.to(this.menuPanel, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  Menu.prototype.hide = function() {
    var _this = this;
    TweenMax.to(this.menuPanel, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        return $(_this.menuPanel).css('z-index', '1');
      }
    });
    return null;
  };

  Menu.prototype.enable = function() {
    var but, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      but.enable();
    }
    return null;
  };

  Menu.prototype.disable = function() {
    var but, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      but.disable();
    }
    return null;
  };

  Menu.prototype.updateInfoContent = function() {
    var but, nextId, prevId, _i, _len, _ref,
      _this = this;
    prevId = this.app.currentSketch - 1;
    if (prevId < 0) {
      prevId = this.app.sketches.length - 1;
    }
    nextId = this.app.currentSketch + 1;
    if (nextId === this.app.sketches.length) {
      nextId = 0;
    }
    TweenMax.to(this.currentButton, 0.5, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        var i, _i, _ref, _results;
        _this.currentButton.innerHTML = '<h1 style="opacity:0">' + _this.data[_this.app.currentSketch].classId + '</h1><div id="current-sketch-content">' + _this.getSketchCopy() + '</div>';
        _this.currentHeader = _this.currentButton.getElementsByTagName('h1')[0];
        _this.currentHolder = document.getElementById('current-sketch-content');
        _this.paras = _this.currentHolder.getElementsByTagName('p');
        $(_this.currentButton).css('opacity', '1');
        TweenMax.to(_this.currentHeader, 0.5, {
          css: {
            opacity: 1
          },
          ease: Power4.easeOut
        });
        _results = [];
        for (i = _i = 0, _ref = _this.paras.length - 1; _i <= _ref; i = _i += 1) {
          if (i < _this.paras.length - 1) {
            _results.push(TweenMax.to(_this.paras[i], 0.5, {
              css: {
                opacity: 1
              },
              ease: Power4.easeOut,
              delay: 0.3 + (i * 0.2)
            }));
          } else {
            _results.push(TweenMax.to(_this.paras[i], 0.5, {
              css: {
                opacity: 1
              },
              ease: Power4.easeOut,
              delay: 0.3 + (i * 0.2),
              onComplete: function() {
                return console.log('ALL TWEENING DONE');
              }
            }));
          }
        }
        return _results;
      }
    });
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      if (but.id !== this.app.currentSketch && but.isActive) {
        but.deselect();
      } else if (but.id === this.app.currentSketch && !but.isActive) {
        but.select();
      }
    }
    return null;
  };

  Menu.prototype.getSketchCopy = function() {
    var str;
    str = "<p class='information-panel-copy' style='opacity:0'>" + this.data[this.app.currentSketch].instructions + "</p>";
    str += "<p class='information-panel-copy' style='opacity:0'>" + this.data[this.app.currentSketch].description + "</p>";
    return str;
  };

  Menu.prototype.handleDivOver = function(e) {
    if (e.target === this.nextButton || e.target === this.menuButtons || e.target === this.currentButton) {
      TweenMax.to(e.target, 0.3, {
        css: {
          color: 'rgb(255, 0, 61)'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  Menu.prototype.handleDivOut = function(e) {
    if (e.target === this.nextButton || e.target === this.menuButtons || e.target === this.currentButton) {
      TweenMax.to(e.target, 2, {
        css: {
          color: '#dedede'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  Menu.prototype.createButtons = function() {
    var but, i, _i, _ref;
    for (i = _i = 0, _ref = this.data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      but = new MenuButton(this.data[i].classId, i);
      this.buttons.push(but);
      this.menuButtons.appendChild(but.view);
    }
    return null;
  };

  return Menu;

})();

PWPData = (function() {
  function PWPData() {}

  PWPData.prototype.data = [
    {
      className: Smoky,
      classId: "Smoky",
      description: "Everyone starts with particles, right? Anyway, I was mucking around with them and liked the sort of smoky, foggy look the sprite had when it was really big.",
      instructions: "Just wiggle your mouse about to disturb the smoke a little."
    }, {
      className: Trails,
      classId: "Trails",
      description: "Mouse trails are pretty ubiquitous too. This one looked more alive when I was wiggling my mouse, so I've added a heading vector that fluctuates across an angle spread. Smaller sizes work better on smaller screens.",
      instructions: "A simple mouse trail."
    }, {
      className: Dots,
      classId: "Dots",
      description: "I've always loved LED grids, chuck in some rhythmic patterns and they hypnotise me. I might come back to this and write an image/text parser for it.",
      instructions: "Lots of settings for this one\nHave a play"
    }, {
      className: Spirals,
      classId: "Spirals",
      description: "Nature is full of Spirals and they're lovely to look at. This one moves between random selections which alters the patterns produced. The strobing effect makes it look more complicated than it is and becomes almost kaleidoscopic. I may have stared at this one for hours.",
      instructions: "It changes automagically, but hitting space will force a new random selection"
    }, {
      className: SineWave,
      classId: "Sine Wave",
      description: "A lot of the previous experiments used sine values of some sort and they look pretty cool too. This one started out as a plain old sine wave, but I chucked in some rotation after staring at spirals and it makes some equally pleasing patterns when it strobes.",
      instructions: "Play with the settings in this one"
    }, {
      className: Stacks,
      classId: "Stacks",
      description: "It's sort of like an abacus.",
      instructions: "Just watch it"
    }, {
      className: Fractals,
      classId: "Fractals",
      description: "....",
      instructions: "...."
    }, {
      className: Radar,
      classId: "Radar",
      description: "....",
      instructions: "...."
    }, {
      className: Ribbon,
      classId: "Ribbon",
      description: "....",
      instructions: "...."
    }, {
      className: Orbits,
      classId: "Orbits",
      description: "....",
      instructions: "...."
    }, {
      className: Comets,
      classId: "Comets",
      description: "....",
      instructions: "...."
    }, {
      className: PlanktonTank,
      classId: "PlanktonTank",
      description: "....",
      instructions: "...."
    }, {
      className: Spirograph,
      classId: "Spirograph",
      description: "....",
      instructions: "...."
    }, {
      className: Squids,
      classId: "Squids",
      description: "....",
      instructions: "...."
    }, {
      className: PictureTile,
      classId: "PictureTile",
      description: "....",
      instructions: "...."
    }, {
      className: ShapeShifter,
      classId: "ShapeShifter",
      description: "....",
      instructions: "...."
    }
  ];

  return PWPData;

})();

App = (function() {
  App.prototype.sketches = null;

  App.prototype.data = null;

  App.prototype.currentSketch = 0;

  App.prototype.numSketches = null;

  App.prototype.liveSketch = null;

  App.prototype.textures = null;

  App.prototype.infoButton = null;

  App.prototype.menuButton = null;

  App.prototype.menuOpen = false;

  App.prototype.infoOpen = true;

  App.prototype.infoPanel = null;

  App.prototype.menuPanel = null;

  App.prototype.stageColor = 0x0a0a0a;

  App.prototype.spacePressed = false;

  App.prototype.degToRad = Math.PI / 180;

  App.prototype.radToDeg = 180 / Math.PI;

  function App() {
    this.selectSketch = __bind(this.selectSketch, this);
    this.prev = __bind(this.prev, this);
    this.next = __bind(this.next, this);
    this.handleKeyPress = __bind(this.handleKeyPress, this);
    this.handleInterfaceOver = __bind(this.handleInterfaceOver, this);
    this.handleInterfaceOut = __bind(this.handleInterfaceOut, this);
    this.handleMenuClick = __bind(this.handleMenuClick, this);
    this.handleInfoClick = __bind(this.handleInfoClick, this);
    this.init = __bind(this.init, this);
    var i, _i, _len, _ref,
      _this = this;
    this.data = new PWPData().data;
    this.renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight);
    this.textures = [PIXI.Texture.fromImage('img/node.png')];
    this.sketches = [];
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      this.sketches.push({
        sketch: new i.className(this.renderer),
        id: i.classId
      });
    }
    this.numSketches = this.sketches.length;
    this.currentSketch = this.sketches.length - 1;
    this["interface"] = document.getElementById('interface');
    this.infoButton = document.getElementById('info-button');
    this.infoButton.onmouseover = this.handleInterfaceOver;
    this.infoButton.onmouseout = this.handleInterfaceOut;
    this.infoButton.onclick = this.handleInfoClick;
    this.menuButton = document.getElementById('menu-button');
    this.menuButton.onmouseover = this.handleInterfaceOver;
    this.menuButton.onmouseout = this.handleInterfaceOut;
    this.menuButton.onclick = this.handleMenuClick;
    this.menuPanel = new Menu(this, this.data);
    this.infoPanel = new InfoPanel();
    this.pointerPosition = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5
    };
    this.mousePressed = false;
    window.onmousemove = function(e) {
      _this.pointerPosition.x = e.pageX;
      _this.pointerPosition.y = e.pageY;
      return null;
    };
    window.onmousedown = function() {
      _this.mousePressed = true;
      return null;
    };
    window.onmouseup = function() {
      _this.mousePressed = false;
      return null;
    };
    window.ontouch = function(e) {
      _this.pointerPosition.x = e.touches[0].pageX;
      _this.pointerPosition.y = e.touches[0].pageY;
      return null;
    };
    this.menuPanel.enable();
    window.onresize = function() {
      var sketch, _j, _len1, _ref1;
      _this.infoPanel.resize();
      _this.renderer.resize(window.innerWidth, window.innerHeight);
      _ref1 = _this.sketches;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        sketch = _ref1[_j];
        sketch.sketch.resize();
      }
      return null;
    };
    this.init();
  }

  App.prototype.init = function() {
    window.onkeyup = this.handleKeyPress;
    return null;
  };

  App.prototype.handleInfoClick = function() {
    if (this.menuOpen) {
      this.handleMenuClick();
    }
    this.infoOpen = !this.infoOpen;
    if (this.infoOpen) {
      this.infoPanel.show();
    } else {
      this.infoPanel.hide();
    }
    return null;
  };

  App.prototype.handleMenuClick = function() {
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    this.menuOpen = !this.menuOpen;
    if (this.menuOpen) {
      this.menuPanel.show();
      TweenMax.to(this.infoButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
    } else {
      this.menuPanel.hide();
      TweenMax.to(this.menuButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
      TweenMax.to(this.infoButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  App.prototype.handleInterfaceOut = function(e) {
    TweenMax.to(e.target, 2, {
      css: {
        color: '#e3e3e3'
      },
      ease: Power4.easeOut
    });
    return null;
  };

  App.prototype.handleInterfaceOver = function(e) {
    TweenMax.to(e.target, 0.15, {
      css: {
        color: 'rgb(255, 0, 61)'
      },
      ease: Power4.easeOut
    });
    return null;
  };

  App.prototype.handleKeyPress = function(e) {
    var unicode;
    e.preventDefault();
    unicode = e.keyCode ? e.keyCode : e.charCode;
    if (unicode === 37) {
      this.prev();
    } else if (unicode === 39) {
      this.next();
    } else if (unicode === 32) {
      this.spacePressed = true;
    }
    return null;
  };

  App.prototype.next = function() {
    var lastSketch;
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('next');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.prev = function() {
    var lastSketch;
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('prev');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.selectSketch = function(id) {
    var lastSketch;
    lastSketch = this.sketches[this.currentSketch];
    this.currentSketch = id;
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.unloadSketch = function(sketch) {
    var _this = this;
    TweenMax.to(sketch.view, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        sketch.unload();
        return _this.loadCurrentSketch();
      }
    });
    return null;
  };

  App.prototype.changeSketch = function(dir) {
    if (dir === 'next') {
      this.currentSketch++;
    } else if (dir === 'prev') {
      this.currentSketch--;
    }
    if (this.currentSketch === this.sketches.length) {
      this.currentSketch = 0;
    } else if (this.currentSketch < 0) {
      this.currentSketch = this.sketches.length - 1;
    }
    return null;
  };

  App.prototype.loadCurrentSketch = function() {
    this.sketches[this.currentSketch].sketch.load();
    this.sketches[this.currentSketch].sketch.view.style.opacity = 0;
    document.body.appendChild(this.sketches[this.currentSketch].sketch.view);
    TweenMax.to(this.sketches[this.currentSketch].sketch.view, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  return App;

})();
