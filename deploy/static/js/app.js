// Generated by CoffeeScript 1.6.3
var AABB, App, ColourConversion, CometParticle, CometSparkParticle, Comets, Dots, Fractals, MathUtils, Menu, Node, Orbits, PWPData, Penrose, PictureTile, Plankton, PlanktonTank, Point, QuadTree, QuadTreeTest, Radar, Ribbon, ShapeShifter, SineWave, Sketch, Smoky, Spirals, Spirograph, SpirographNode, SquidNode, Squids, Stacks, TessellationOne, Trails,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Sketch = (function() {
  function Sketch(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.view = new PIXI.DisplayObjectContainer();
    this.cancelled = false;
    this.loaded = false;
    this.stage = null;
    this.gui = null;
  }

  Sketch.prototype.load = function() {
    this.cancelled = false;
    this.loaded = true;
    return null;
  };

  Sketch.prototype.unload = function() {
    this.cancelled = true;
    return null;
  };

  Sketch.prototype.update = function() {
    if (this.cancelled) {
      return;
    }
    return null;
  };

  Sketch.prototype.resize = function() {
    return null;
  };

  Sketch.prototype.makeGui = function() {
    this.gui = new dat.GUI({
      autoPlace: false
    });
    this.gui.domElement.style.zIndex = 100;
    this.gui.domElement.style.position = 'absolute';
    this.gui.domElement.style.top = 0;
    this.gui.domElement.style.left = 0;
    this.gui.domElement.style.height = 'auto';
    this.gui.close();
    return null;
  };

  return Sketch;

})();

/*
Colour conversion utils
Mostly nicked from the interwebs

Main source: http://blog.crondesign.com/2011/02/actionscriptjavascript-colour-mode.html
hsbToRgb conversion from: http://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately
*/


ColourConversion = (function() {
  function ColourConversion() {}

  ColourConversion.hexToRgb = function(hex) {
    var rgb;
    rgb = [];
    rgb.push(hex >> 16);
    rgb.push(hex >> 8 & 0xFF);
    rgb.push(hex & 0xFF);
    return rgb;
  };

  ColourConversion.rgbToHex = function(rgb) {
    var hex;
    hex = rgb[0] << 16 ^ rgb[1] << 8 ^ rgb[2];
    return hex;
  };

  ColourConversion.hsbToRgb = function(hsb) {
    var b, check, f, g, h, i, p, q, r, s, t, v;
    h = hsb[0] / 360;
    s = hsb[1] / 100;
    v = hsb[2] / 100;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    check = i % 6;
    if (check === 0) {
      r = v;
      g = t;
      b = p;
    }
    if (check === 1) {
      r = q;
      g = v;
      b = p;
    }
    if (check === 2) {
      r = p;
      g = v;
      b = t;
    }
    if (check === 3) {
      r = p;
      g = q;
      b = v;
    }
    if (check === 4) {
      r = t;
      g = p;
      b = v;
    }
    if (check === 5) {
      r = v;
      g = p;
      b = q;
    }
    return [r * 255, g * 255, b * 255];
  };

  ColourConversion.rgbToHsb = function(rgb) {
    var f, hue, i, sat, val, x;
    rgb[0] /= 255;
    rgb[1] /= 255;
    rgb[2] /= 255;
    x = Math.min(Math.min(rgb[0], rgb[1]), rgb[2]);
    val = Math.max(Math.max(rgb[0], rgb[1]), rgb[2]);
    if (x === val) {
      return [void 0, 0, val * 100];
    }
    if (x === rgb[0]) {
      f = rgb[1] - rgb[2];
    } else if (x === rgb[1]) {
      f = rgb[2] - rgb[0];
    } else {
      f = rgb[0] - rgb[1];
    }
    if (x === rgb[0]) {
      i = 3;
    } else if (x === rgb[1]) {
      i = 5;
    } else {
      i = 1;
    }
    hue = Math.floor((i - f / (val - x)) * 60) % 360;
    sat = Math.floor(((val - x) / val) * 100);
    val = Math.floor(val * 100);
    return [hue, sat, val];
  };

  ColourConversion.hsbToHex = function(hsb) {
    var rgb;
    rgb = ColourConversion.hsbToRgb(hsb);
    return ColourConversion.rgbToHex(rgb);
  };

  ColourConversion.hexToHsb = function(hex) {
    var rgb;
    rgb = ColourConversion.hexToRgb(hex);
    return ColourConversion.rgbToHsb(rgb);
  };

  return ColourConversion;

})();

Node = (function() {
  function Node(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.fillPositions = __bind(this.fillPositions, this);
    this.checkPositionsLength = __bind(this.checkPositionsLength, this);
    this.moveTo = __bind(this.moveTo, this);
    this.position = new Point(x, y, z);
    this.velocity = new Point();
    this.positions = [];
    this.positions.push(this.position.clone());
    this.recordedPositions = 1;
  }

  Node.prototype.moveTo = function(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.position.x = x;
    this.position.y = y;
    this.position.z = z;
    this.positions.push(this.position.clone());
    this.checkPositionsLength();
    return null;
  };

  Node.prototype.checkPositionsLength = function() {
    while (this.positions.length > this.recordedPositions) {
      this.positions.splice(0, 1);
    }
    return null;
  };

  Node.prototype.fillPositions = function() {
    while (this.positions.length < this.recordedPositions) {
      this.positions.push(this.position.clone());
    }
    return null;
  };

  return Node;

})();

CometSparkParticle = (function(_super) {
  __extends(CometSparkParticle, _super);

  function CometSparkParticle(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.update = __bind(this.update, this);
    this.setColor = __bind(this.setColor, this);
    this.newLife = __bind(this.newLife, this);
    CometSparkParticle.__super__.constructor.call(this, x, y, z);
    this.life = 0;
    this.totalLife = 0;
    this.minLife = 10;
    this.maxLife = 30;
    this.minSpeed = 0.4;
    this.maxSpeed = 1.5;
    this.recordedPositions = 30;
    this.fillPositions();
    this.newLife();
    this.hsb = [300, 66, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.view = new PIXI.Sprite(window.app.textures[0]);
    this.view.pivot.x = this.view.pivot.y = 16;
    this.view.tint = this.hex;
  }

  CometSparkParticle.prototype.newLife = function() {
    this.totalLife = Math.round(this.minLife + (Math.random() * (this.maxLife - this.minLife)));
    this.life = this.totalLife;
    this.velocity.x = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    this.velocity.y = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    if (Math.random() < 0.5) {
      this.velocity.x *= -1;
    }
    if (Math.random() < 0.5) {
      this.velocity.y *= -1;
    }
    return null;
  };

  CometSparkParticle.prototype.setColor = function(value) {
    this.hsb[0] = value;
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.view.tint = this.hex;
    return null;
  };

  CometSparkParticle.prototype.update = function() {
    if (this.life === 0) {
      return;
    }
    this.moveTo(this.position.x + this.velocity.x, this.position.y + this.velocity.y, this.position.z + this.velocity.z);
    this.life--;
    this.view.scale.x = this.view.scale.y = 0.1 + (Math.random() * 0.3);
    this.view.alpha = 0.2 + (Math.random() * 1.2);
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    return null;
  };

  return CometSparkParticle;

})(Node);

CometParticle = (function(_super) {
  __extends(CometParticle, _super);

  function CometParticle(x, y, z) {
    var i, _i, _ref;
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.newSpark = __bind(this.newSpark, this);
    this.fireSpark = __bind(this.fireSpark, this);
    this.updateSparks = __bind(this.updateSparks, this);
    this.update = __bind(this.update, this);
    this.headForMouse = __bind(this.headForMouse, this);
    this.randomiseVelocity = __bind(this.randomiseVelocity, this);
    this.setSparkColor = __bind(this.setSparkColor, this);
    this.setColor = __bind(this.setColor, this);
    CometParticle.__super__.constructor.call(this, x, y, z);
    this.life = 240;
    this.totalLife = 240;
    this.maxSpeed = 40;
    this.minSpeed = 20;
    this.children = [];
    this.pool = [];
    this.maxChildren = 5;
    this.recordedPositions = 30;
    this.fillPositions();
    this.view = new PIXI.DisplayObjectContainer();
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.main = new PIXI.Sprite(window.app.textures[0]);
    this.main.pivot.x = this.main.pivot.y = 16;
    this.color = 240;
    this.setColor(this.color);
    this.sparkColor = 300;
    this.view.addChild(this.main);
    for (i = _i = 0, _ref = this.maxChildren; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.fireSpark();
    }
  }

  CometParticle.prototype.setColor = function(value) {
    var hex, hsb;
    this.color = value;
    hsb = [this.color, 18, 100];
    hex = ColourConversion.hsbToHex(hsb);
    this.main.tint = hex;
    return null;
  };

  CometParticle.prototype.setSparkColor = function(value) {
    var spark, _i, _len, _ref;
    this.sparkColor = value;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      spark = _ref[_i];
      spark.setColor(this.sparkColor);
    }
    return null;
  };

  CometParticle.prototype.randomiseVelocity = function(ranx, rany) {
    if (ranx == null) {
      ranx = true;
    }
    if (rany == null) {
      rany = true;
    }
    if (ranx) {
      this.velocity.x = this.minSpeed + (Math.random() * (this.maxSpeed - this.minSpeed));
    }
    if (rany) {
      this.velocity.y = -(this.maxSpeed * 0.1) + (Math.random() * (this.maxSpeed * 0.2));
    }
    return null;
  };

  CometParticle.prototype.headForMouse = function() {
    var easing, xdif, ydif;
    easing = 25;
    xdif = window.app.pointerPosition.x - this.position.x;
    ydif = window.app.pointerPosition.y - this.position.y;
    this.velocity.x = xdif / easing;
    this.velocity.y = ydif / easing;
    return null;
  };

  CometParticle.prototype.update = function() {
    if (this.life === 0) {
      return;
    }
    this.moveTo(this.position.x + this.velocity.x, this.position.y + this.velocity.y, this.position.z + this.velocity.z);
    this.velocity.x *= 0.98;
    this.velocity.y *= 0.98;
    this.velocity.z *= 0.98;
    this.life--;
    this.main.scale.x = this.main.scale.y = 0.7 + (Math.random() * 2);
    this.view.alpha = this.life / this.totalLife;
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.updateSparks();
    while (this.children.length < this.maxChildren) {
      this.fireSpark();
    }
    return null;
  };

  CometParticle.prototype.updateSparks = function() {
    var i, spark, _i, _ref;
    for (i = _i = _ref = this.children.length - 1; _i >= 0; i = _i += -1) {
      spark = this.children[i];
      spark.update();
      if (spark.life === 0) {
        this.children.splice(i, 1);
        this.pool.push(spark);
        this.view.removeChild(spark.view);
      }
    }
    return null;
  };

  CometParticle.prototype.fireSpark = function() {
    var spark;
    spark = this.newSpark();
    this.children.push(spark);
    this.view.addChild(spark.view);
    return null;
  };

  CometParticle.prototype.newSpark = function() {
    var spark;
    if (this.pool.length > 0) {
      spark = this.pool[0];
      this.pool.splice(0, 1);
    } else {
      spark = new CometSparkParticle();
      spark.setColor(this.sparkColor);
    }
    spark.position.x = 0;
    spark.position.y = 0;
    spark.positions = [];
    spark.fillPositions();
    spark.newLife();
    return spark;
  };

  return CometParticle;

})(Node);

Comets = (function(_super) {
  __extends(Comets, _super);

  Comets.prototype.particles = [];

  Comets.prototype.pool = [];

  function Comets(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.resize = __bind(this.resize, this);
    this.newTimeLimit = __bind(this.newTimeLimit, this);
    this.newComet = __bind(this.newComet, this);
    this.setCometColors = __bind(this.setCometColors, this);
    this.fireComet = __bind(this.fireComet, this);
    this.drawPaths = __bind(this.drawPaths, this);
    this.setSparkColor = __bind(this.setSparkColor, this);
    this.setTrailColor = __bind(this.setTrailColor, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Comets.__super__.constructor.call(this, this.renderer, this.name);
  }

  Comets.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.maxComets = 40;
      this.minFrames = 5;
      this.maxFrames = 10;
      this.timeLimit = 0;
      this.cometColor = 240;
      this.sparkColor = 300;
      this.trailColor = 240;
      this.trailHsb = [0, 18, 100];
      this.setTrailColor(this.trailColor);
      this.newTimeLimit();
      this.gui.add(this, 'maxComets', 1, 100);
      this.gui.add(this, 'minFrames', 1, 100);
      this.gui.add(this, 'maxFrames', 1, 100);
      this.gui.add(this, 'cometColor', 0, 360).onFinishChange(function() {
        return _this.setCometColors();
      });
      this.gui.add(this, 'trailColor', 0, 360).onChange(function() {
        return _this.setTrailColor(_this.trailColor);
      });
      this.gui.add(this, 'sparkColor', 0, 360).onChange(function() {
        return _this.setSparkColor(_this.sparkColor);
      });
      this.graphics = new PIXI.Graphics();
      this.view.addChild(this.graphics);
    }
    this.timeout = 1;
    Comets.__super__.load.call(this);
    return null;
  };

  Comets.prototype.unload = function() {
    Comets.__super__.unload.call(this);
    return null;
  };

  Comets.prototype.update = function() {
    var comet, i, _i, _ref;
    Comets.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.timeout--;
    if (this.timeout === 0) {
      if (this.particles.length < this.maxComets) {
        this.newTimeLimit();
        this.timeout = this.timeLimit;
        this.fireComet();
      } else {
        this.timeout++;
      }
    }
    for (i = _i = _ref = this.particles.length - 1; _i >= 0; i = _i += -1) {
      comet = this.particles[i];
      comet.randomiseVelocity(false);
      if (window.app.mousePressed) {
        comet.headForMouse();
      }
      comet.update();
      if (comet.life === 0 || comet.position.x > window.innerWidth) {
        this.particles.splice(i, 1);
        this.pool.push(comet);
        this.view.removeChild(comet.view);
      }
    }
    this.drawPaths();
    return null;
  };

  Comets.prototype.setTrailColor = function(value) {
    this.trailColor = value;
    this.trailHsb[0] = this.trailColor;
    this.trailHex = ColourConversion.hsbToHex(this.trailHsb);
    return null;
  };

  Comets.prototype.setSparkColor = function(value) {
    var comet, _i, _len, _ref;
    this.sparkColor = value;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      comet.setSparkColor(this.sparkColor);
    }
    return null;
  };

  Comets.prototype.drawPaths = function() {
    var comet, i, inc, _i, _j, _len, _ref, _ref1;
    this.graphics.clear();
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      inc = 1 / comet.positions.length;
      for (i = _j = 0, _ref1 = comet.positions.length - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.graphics.lineStyle(1, this.trailHex, (i * inc) * (comet.life / comet.totalLife));
        this.graphics.moveTo(comet.positions[i].x, comet.positions[i].y);
        this.graphics.lineTo(comet.positions[i + 1].x, comet.positions[i + 1].y);
      }
    }
    return null;
  };

  Comets.prototype.fireComet = function() {
    var comet;
    comet = this.newComet();
    this.particles.push(comet);
    this.view.addChild(comet.view);
    return null;
  };

  Comets.prototype.setCometColors = function() {
    var comet, _i, _len, _ref;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      comet = _ref[_i];
      comet.setColor(this.cometColor);
    }
    return null;
  };

  Comets.prototype.newComet = function() {
    var comet;
    if (this.pool.length === 0) {
      comet = new CometParticle();
    } else {
      comet = this.pool[0];
      this.pool.splice(0, 1);
    }
    comet.setColor(this.cometColor);
    comet.setSparkColor(this.sparkColor);
    comet.position.x = 0;
    comet.position.y = Math.random() * window.innerHeight;
    comet.randomiseVelocity();
    comet.positions = [];
    comet.fillPositions();
    comet.life = comet.totalLife;
    return comet;
  };

  Comets.prototype.newTimeLimit = function() {
    this.timeLimit = Math.round(this.minFrames + (Math.random() * (this.maxFrames - this.minFrames)));
    return null;
  };

  Comets.prototype.resize = function() {
    return null;
  };

  return Comets;

})(Sketch);

Dots = (function(_super) {
  __extends(Dots, _super);

  Dots.id = 'Dots';

  Dots.prototype.dots = [];

  Dots.prototype.deadDots = [];

  Dots.prototype.xCounter = 0;

  Dots.prototype.xLimit = 0;

  Dots.prototype.xDir = 1;

  Dots.prototype.yCounter = 0;

  Dots.prototype.yLimit = 0;

  Dots.prototype.yDir = 1;

  Dots.prototype.curX = 0;

  Dots.prototype.curY = 0;

  Dots.prototype.mouseX = 0;

  Dots.prototype.mouseY = 0;

  Dots.prototype.easeX = 0;

  Dots.prototype.easeY = 0;

  Dots.prototype.spriteSize = 32;

  Dots.prototype.invert = true;

  Dots.prototype.mouseTrail = true;

  Dots.prototype.xFollow = false;

  Dots.prototype.xBounce = true;

  Dots.prototype.xLeft = false;

  Dots.prototype.xRight = false;

  Dots.prototype.xOff = false;

  Dots.prototype.lastX = 'follow';

  Dots.prototype.yFollow = false;

  Dots.prototype.yBounce = false;

  Dots.prototype.yUp = false;

  Dots.prototype.yDown = true;

  Dots.prototype.yOff = false;

  Dots.prototype.lastY = 'follow';

  function Dots(renderer) {
    this.renderer = renderer;
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.updateGui = __bind(this.updateGui, this);
    Dots.__super__.constructor.call(this, this.renderer, this.name);
  }

  Dots.prototype.updateGui = function() {
    var c, _i, _len, _ref;
    _ref = this.gui.__controllers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.updateDisplay();
    }
    return null;
  };

  Dots.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.createSprites();
      this.makeGui();
      this.gui.add(this, 'spriteSize', 16, 128, 8).onFinishChange(function(val) {
        _this.spriteSize = val;
        return _this.resize();
      });
      this.gui.add(this, 'invert');
      this.gui.add(this, 'mouseTrail');
      this.gui.add(this, 'xFollow').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xFollow = true) {
          _this.xBounce = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'follow';
          _this.xBounce = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xBounce').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xBounce = true) {
          _this.xFollow = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'bounce';
          _this.xFollow = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xLeft').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xLeft = true) {
          _this.xDir = -1;
          _this.xFollow = _this.xBounce = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'left';
          _this.xFollow = _this.xBounce = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xRight').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xRight = true) {
          _this.xDir = 1;
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xOff = false;
        } else {
          _this.lastX = 'right';
          _this.xFollow = _this.xBounce = _this.xLeft = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xOff').onChange(function(val) {
        _this.xOff = val;
        if (_this.xOff) {
          if (_this.xFollow) {
            _this.lastX = 'follow';
          } else if (_this.xBounce) {
            _this.lastX = 'bounce';
          } else if (_this.xLeft) {
            _this.lastX = 'left';
          } else if (_this.xRight) {
            _this.lastX = 'right';
          }
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xRight = false;
        } else {
          if (_this.lastX === 'follow') {
            _this.xFollow = true;
          } else if (_this.lastX === 'bounce') {
            _this.xBounce = true;
          } else if (_this.lastX === 'left') {
            _this.xLeft = true;
          } else if (_this.lastX === 'right') {
            _this.xRight = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yFollow').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yFollow = true) {
          _this.yBounce = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'follow';
          _this.yBounce = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yBounce').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yBounce = true) {
          _this.yFollow = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'bounce';
          _this.yFollow = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yUp').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yUp = true) {
          _this.yDir = -1;
          _this.yFollow = _this.yBounce = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'left';
          _this.yFollow = _this.yBounce = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yDown').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yDown = true) {
          _this.yDir = 1;
          _this.yFollow = _this.yBounce = _this.yUp = _this.yOff = false;
        } else {
          _this.lastY = 'right';
          _this.yFollow = _this.yBounce = _this.yUp = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yOff').onChange(function(val) {
        _this.yOff = val;
        if (_this.yOff) {
          if (_this.yFollow) {
            _this.lastY = 'follow';
          } else if (_this.yBounce) {
            _this.lastY = 'bounce';
          } else if (_this.yUp) {
            _this.lastY = 'up';
          } else if (_this.yDown) {
            _this.lastY = 'down';
          }
          _this.yFollow = _this.yBounce = _this.yUp = _this.yDown = false;
        } else {
          if (_this.lastY === 'follow') {
            _this.yFollow = true;
          } else if (_this.lastY === 'bounce') {
            _this.yBounce = true;
          } else if (_this.lastY === 'up') {
            _this.yUp = true;
          } else if (_this.lastY === 'down') {
            _this.yDown = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.close();
    }
    Dots.__super__.load.call(this);
    this.xLimit = this.dots.length;
    this.yLimit = this.dots[0].length;
    return null;
  };

  Dots.prototype.unload = function() {
    Dots.__super__.unload.call(this);
    return null;
  };

  Dots.prototype.update = function() {
    var i, j, sprite, tgtAlpha, _i, _j, _ref, _ref1;
    Dots.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.handleMouseMove();
    if (this.xFollow) {
      this.xCounter = this.curX;
    }
    if (this.yFollow) {
      this.yCounter = this.curY;
    }
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        sprite = this.dots[i][j];
        tgtAlpha = 1;
        if (this.invert) {
          tgtAlpha = 0;
        }
        if (!this.xOff && i === this.xCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (!this.yOff && j === this.yCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (this.invert) {
          if (sprite.alpha < 1) {
            sprite.alpha += 0.05;
            sprite.scale.x += 0.05;
            sprite.scale.y += 0.05;
            if (sprite.alpha > 1) {
              sprite.alpha = 1;
            }
            if (sprite.scale.x > 1) {
              sprite.scale.x = sprite.scale.y = this.spriteSize / 32;
            }
          }
        } else {
          if (sprite.alpha > 0) {
            sprite.alpha -= 0.05;
            sprite.scale.x -= 0.05;
            sprite.scale.y -= 0.05;
            if (sprite.alpha < 0) {
              sprite.alpha = 0;
            }
            if (sprite.scale.x < 0) {
              sprite.scale.x - (sprite.scale.y = 0);
            }
          }
        }
      }
    }
    if (!this.xOff) {
      this.xCounter += this.xDir;
      if (this.xLeft || this.xRight) {
        this.xCounter %= this.xLimit;
        if (this.xCounter < 0) {
          this.xCounter = this.xLimit - 1;
        }
      } else if (this.xBounce) {
        if (this.xCounter === this.xLimit) {
          this.xCounter = this.xLimit - 2;
          this.xDir *= -1;
        } else if (this.xCounter < 0) {
          this.xCounter = 1;
          this.xDir *= -1;
        }
      }
    }
    if (!this.yOff) {
      this.yCounter += this.yDir;
      if (this.yUp || this.yDown) {
        this.yCounter %= this.yLimit;
        if (this.yCounter < 0) {
          this.yCounter = this.yLimit - 1;
        }
      } else if (this.yBounce) {
        if (this.yCounter === this.yLimit) {
          this.yCounter = this.yLimit - 2;
          this.yDir *= -1;
        } else if (this.yCounter < 0) {
          this.yCounter = 1;
          this.yDir *= -1;
        }
      }
    }
    this.easeX += (this.mouseX - this.easeX) / 45;
    this.easeY += (this.mouseY - this.easeY) / 45;
    this.curX = Math.floor(this.easeX / this.spriteSize);
    this.curY = Math.floor(this.easeY / this.spriteSize);
    return null;
  };

  Dots.prototype.resize = function() {
    var i, j, _i, _j, _ref, _ref1;
    if (this.loaded) {
      for (i = _i = _ref = this.dots.length - 1; _i >= 0; i = _i += -1) {
        for (j = _j = _ref1 = this.dots[i].length - 1; _j >= 0; j = _j += -1) {
          this.view.removeChild(this.dots[i][j]);
          this.dots[i].splice(j, 1);
        }
      }
      this.dots = [];
      this.createSprites();
      this.xLimit = this.dots.length;
      this.yLimit = this.dots[0].length;
    }
    return null;
  };

  Dots.prototype.handleMouseMove = function() {
    var tgtAlpha, xid, yid;
    this.mouseX = window.app.pointerPosition.x;
    this.mouseY = window.app.pointerPosition.y;
    if (this.mouseTrail) {
      xid = Math.floor(this.mouseX / this.spriteSize);
      yid = Math.floor(this.mouseY / this.spriteSize);
      tgtAlpha = 1;
      if (this.invert) {
        tgtAlpha = 0;
      }
      this.dots[xid][yid].alpha = tgtAlpha;
      if (this.dots[xid] && this.dots[xid][yid - 1]) {
        this.dots[xid][yid - 1].alpha = tgtAlpha;
        this.dots[xid][yid - 1].scale.x = this.dots[xid][yid - 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid] && this.dots[xid][yid + 1]) {
        this.dots[xid][yid + 1].alpha = tgtAlpha;
        this.dots[xid][yid + 1].scale.x = this.dots[xid][yid + 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid - 1] && this.dots[xid - 1][yid]) {
        this.dots[xid - 1][yid].alpha = tgtAlpha;
        this.dots[xid - 1][yid].scale.x = this.dots[xid - 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid + 1] && this.dots[xid + 1][yid]) {
        this.dots[xid + 1][yid].alpha = tgtAlpha;
        this.dots[xid + 1][yid].scale.x = this.dots[xid + 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
    }
    return null;
  };

  Dots.prototype.createSprites = function() {
    var i, j, sp, _i, _j, _ref, _ref1;
    this.xCount = Math.round(window.innerWidth / this.spriteSize);
    this.yCount = Math.round(window.innerHeight / this.spriteSize);
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      this.dots[i] = [];
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        if (this.deadDots.length === 0) {
          sp = new PIXI.Sprite(window.app.textures[0]);
        } else {
          sp = this.deadDots[0];
          this.deadDots.splice(0, 1);
        }
        sp.scale.x = sp.scale.y = this.spriteSize / 32;
        sp.position.x = i * this.spriteSize;
        sp.position.y = j * this.spriteSize;
        this.dots[i][j] = sp;
        sp.alpha = 0;
        this.view.addChild(sp);
      }
    }
    return null;
  };

  return Dots;

})(Sketch);

Fractals = (function(_super) {
  __extends(Fractals, _super);

  Fractals.prototype.minSize = 32;

  Fractals.prototype.startSize = 400;

  Fractals.prototype.divisor = 2.5;

  Fractals.prototype.sprites = [];

  Fractals.prototype.deadSprites = [];

  function Fractals(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.getSprite = __bind(this.getSprite, this);
    this.addSprite = __bind(this.addSprite, this);
    this.redraw = __bind(this.redraw, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Fractals.__super__.constructor.call(this, this.renderer, this.name);
  }

  Fractals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderView = new PIXI.Sprite(this.renderTex);
      this.view.addChild(this.renderView);
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.canvas = new PIXI.DisplayObjectContainer();
      this.gui.add(this, 'minSize', 1, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'startSize', 10, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'divisor', 2, 6).onFinishChange(function() {
        return _this.redraw();
      });
    }
    this.createSprites();
    Fractals.__super__.load.call(this);
    return null;
  };

  Fractals.prototype.unload = function() {
    Fractals.__super__.unload.call(this);
    return null;
  };

  Fractals.prototype.update = function() {
    Fractals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    return null;
  };

  Fractals.prototype.resize = function() {
    this.redraw();
    return null;
  };

  Fractals.prototype.redraw = function() {
    if (this.renderView) {
      this.renderTex.destroy();
      this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderView.setTexture(this.renderTex);
      this.sprites = [];
      this.createSprites();
    }
    return null;
  };

  Fractals.prototype.createSprites = function() {
    this.addSprite(window.innerWidth * 0.5, window.innerHeight * 0.5, this.startSize);
    return null;
  };

  Fractals.prototype.addSprite = function(x, y, size) {
    var _this = this;
    this.sprite.position.x = x;
    this.sprite.position.y = y;
    this.sprite.scale.x = this.sprite.scale.y = size / 32;
    this.canvas.addChild(this.sprite);
    this.renderTex.render(this.canvas);
    this.canvas.removeChild(this.sprite);
    if (size > this.minSize) {
      return setTimeout(function() {
        _this.addSprite(x + size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x - size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x, y + size / _this.divisor, size / _this.divisor);
        return _this.addSprite(x, y - size / _this.divisor, size / _this.divisor);
      }, 500);
    }
  };

  Fractals.prototype.getSprite = function() {
    if (this.deadSprites.length === 0) {
      return new PIXI.Sprite(window.app.textures[0]);
    } else {
      return this.deadSprites.splice(0, 1)[0];
    }
  };

  return Fractals;

})(Sketch);

MathUtils = (function() {
  function MathUtils() {}

  MathUtils.degToRadValue = Math.PI / 180;

  MathUtils.radToDegValue = 180 / Math.PI;

  MathUtils.twoPI = 2 * Math.PI;

  MathUtils.goldenRatio = (1 + Math.sqrt(5)) / 2;

  MathUtils.degToRad = function(val) {
    return val * MathUtils.degToRadValue;
  };

  MathUtils.radToDeg = function(val) {
    return val * MathUtils.radToDegValue;
  };

  return MathUtils;

})();

Orbits = (function(_super) {
  __extends(Orbits, _super);

  function Orbits(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.drawTail = __bind(this.drawTail, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Orbits.__super__.constructor.call(this, this.renderer, this.name);
  }

  Orbits.prototype.load = function() {
    var i, n, tx, ty, _i, _ref;
    if (!this.loaded) {
      this.makeGui();
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 19.6;
      this.baseNode.yIncrement = 35.2;
      this.baseNode.xOffset = 726;
      this.baseNode.yOffset = 217;
      this.numSattelites = 10;
      this.easing = 50;
      this.tailLength = 60;
      this.tailWidth = 6.2;
      this.initialSpacing = 60;
      this.nodes = [];
      this.maxSpeed = 175;
      this.tailColour = 0x8CF1FF;
      for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        tx = this.midx + (Math.cos(Math.random() * Math.PI) * this.initialSpacing);
        ty = this.midy + (Math.sin(Math.random() * Math.PI) * this.initialSpacing);
        n = new Node(tx, ty);
        n.recordedPositions = this.tailLength;
        n.fillPositions();
        this.nodes.push(n);
      }
      this.graphics = new PIXI.Graphics();
      this.view.addChild(this.graphics);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this, 'tailWidth', 2, 100);
      this.gui.add(this, 'maxSpeed', 2, 1000);
      this.gui.add(this, 'easing', 2, 100);
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
    }
    Orbits.__super__.load.call(this);
    return null;
  };

  Orbits.prototype.unload = function() {
    Orbits.__super__.unload.call(this);
    return null;
  };

  Orbits.prototype.update = function() {
    var i, n, newx, newy, xdif, ydif, _i, _ref;
    Orbits.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.graphics.clear();
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(MathUtils.degToRad(this.baseNode.xSin)) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(MathUtils.degToRad(this.baseNode.ySin)) * this.baseNode.yOffset);
    for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = this.nodes[i];
      xdif = this.baseNode.position.x - n.position.x;
      ydif = this.baseNode.position.y - n.position.y;
      n.velocity.x += xdif / this.easing;
      n.velocity.y += ydif / this.easing;
      if (n.velocity.x > this.maxSpeed) {
        n.velocity.x = this.maxSpeed;
      } else if (n.velocity.x < -this.maxSpeed) {
        n.velocity.x = -this.maxSpeed;
      }
      if (n.velocity.y > this.maxSpeed) {
        n.velocity.y = this.maxSpeed;
      } else if (n.velocity.y < -this.maxSpeed) {
        n.velocity.y = -this.maxSpeed;
      }
      newx = n.position.x + n.velocity.x;
      newy = n.position.y + n.velocity.y;
      n.moveTo(newx, newy);
      this.drawTail(n);
    }
    return null;
  };

  Orbits.prototype.resize = function() {
    return null;
  };

  Orbits.prototype.drawTail = function(node) {
    var i, inc, pt1, pt2, tailInc, _i, _ref;
    inc = 1 / this.tailLength;
    tailInc = this.tailWidth / this.tailLength;
    for (i = _i = 0, _ref = this.tailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.tailWidth > 1) {
        this.graphics.lineStyle(tailInc * i, this.tailColour, i * inc);
      } else {
        this.graphics.lineStyle(this.tailWidth, this.tailColour, i * inc);
      }
      pt1 = node.positions[i];
      pt2 = node.positions[i + 1];
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt2.x, pt2.y);
    }
    return null;
  };

  return Orbits;

})(Sketch);

Penrose = (function(_super) {
  __extends(Penrose, _super);

  function Penrose(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.getColour = __bind(this.getColour, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Penrose.__super__.constructor.call(this, this.renderer, this.name);
  }

  Penrose.prototype.load = function() {
    var angA, angB, i, t, tri, _i,
      _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.canvas = new PIXI.Graphics();
      this.view.addChild(this.canvas);
      this.canvas.position.x = window.innerWidth * 0.5;
      this.canvas.position.y = window.innerHeight * 0.5;
      this.colA = 3223857;
      this.colB = 10944261;
      this.gui.addColor(this, 'colA').name('Colour A').onChange(function() {
        if (typeof _this.colA === 'string') {
          _this.colA = _this.colA.replace('#', '0x');
          _this.colA = parseInt(_this.colA);
        }
        return _this.drawTriangles(_this.triangles, _this.iterations + 1);
      });
      this.gui.addColor(this, 'colB').name('Colour B').onChange(function() {
        if (typeof _this.colB === 'string') {
          _this.colB = _this.colB.replace('#', '0x');
          _this.colB = parseInt(_this.colB);
        }
        return _this.drawTriangles(_this.triangles, _this.iterations + 1);
      });
    }
    this.triangles = [];
    for (i = _i = 0; _i < 10; i = ++_i) {
      angA = i * 36;
      angB = (i + 1) * 36;
      angB %= 360;
      tri = {
        colour: 0,
        a: [0, 0],
        b: [Math.cos(MathUtils.degToRad(angA)) * 50, Math.sin(MathUtils.degToRad(angA)) * 50],
        c: [Math.cos(MathUtils.degToRad(angB)) * 50, Math.sin(MathUtils.degToRad(angB)) * 50]
      };
      if (i % 2 === 0) {
        t = tri.b;
        tri.b = tri.c;
        tri.c = t;
      }
      this.triangles.push(tri);
    }
    this.iterations = 0;
    this.waiting = false;
    this.drawTriangles(this.triangles, 1 + this.iterations);
    Penrose.__super__.load.call(this);
    return null;
  };

  Penrose.prototype.unload = function() {
    Penrose.__super__.unload.call(this);
    return null;
  };

  Penrose.prototype.update = function() {
    Penrose.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.mousePressed && !this.waiting) {
      this.waiting = true;
    } else if (!window.app.mousePressed && this.waiting) {
      this.waiting = false;
      if (this.iterations < 7) {
        this.triangles = this.subdivideTriangles(this.triangles);
        this.iterations++;
        this.drawTriangles(this.triangles, 1 + this.iterations);
      }
    }
    return null;
  };

  Penrose.prototype.resize = function() {
    return null;
  };

  Penrose.prototype.drawTriangles = function(triangles, scale) {
    var tri, _i, _len;
    if (scale == null) {
      scale = 10;
    }
    this.canvas.clear();
    this.canvas.lineStyle(1, 0x000000);
    for (_i = 0, _len = triangles.length; _i < _len; _i++) {
      tri = triangles[_i];
      if (tri.colour === 1) {
        this.canvas.beginFill(this.getColour(tri.a, this.colB));
      } else {
        this.canvas.beginFill(this.getColour(tri.a, this.colA));
      }
      this.canvas.moveTo(tri.b[0] * scale, tri.b[1] * scale);
      this.canvas.lineTo(tri.a[0] * scale, tri.a[1] * scale);
      this.canvas.lineTo(tri.c[0] * scale, tri.c[1] * scale);
      this.canvas.endFill();
    }
    return this.canvas.lineStyle(null);
  };

  Penrose.prototype.getColour = function(pt, col) {
    var dist, hsb, xd, yd;
    xd = pt[0] * (this.iterations + 1);
    yd = pt[1] * (this.iterations + 1);
    hsb = ColourConversion.hexToHsb(col);
    dist = Math.sqrt((xd * xd) + (yd * yd));
    hsb[0] += 120 * (dist / window.innerHeight);
    return ColourConversion.hsbToHex(hsb);
  };

  Penrose.prototype.findMidpoint = function(a, b) {
    var val;
    val = [];
    val.push(a[0] + (b[0] - a[0]) / MathUtils.goldenRatio);
    val.push(a[1] + (b[1] - a[1]) / MathUtils.goldenRatio);
    return val;
  };

  Penrose.prototype.subdivideTriangles = function(triangles) {
    var arr, p, q, r, tri, _i, _len;
    arr = [];
    for (_i = 0, _len = triangles.length; _i < _len; _i++) {
      tri = triangles[_i];
      if (tri.colour === 0) {
        p = this.findMidpoint(tri.a, tri.b);
        arr.push({
          colour: 0,
          a: tri.c,
          b: p,
          c: tri.b
        });
        arr.push({
          colour: 1,
          a: p,
          b: tri.c,
          c: tri.a
        });
      } else {
        q = this.findMidpoint(tri.b, tri.a);
        r = this.findMidpoint(tri.b, tri.c);
        arr.push({
          colour: 1,
          a: r,
          b: tri.c,
          c: tri.a
        });
        arr.push({
          colour: 1,
          a: q,
          b: r,
          c: tri.b
        });
        arr.push({
          colour: 0,
          a: r,
          b: q,
          c: tri.a
        });
      }
    }
    return arr;
  };

  return Penrose;

})(Sketch);

PictureTile = (function(_super) {
  __extends(PictureTile, _super);

  function PictureTile(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.drawPixels = __bind(this.drawPixels, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.handleVideoError = __bind(this.handleVideoError, this);
    this.handleVideo = __bind(this.handleVideo, this);
    this.load = __bind(this.load, this);
    PictureTile.__super__.constructor.call(this, this.renderer, this.name);
  }

  PictureTile.prototype.load = function() {
    var i, j, p, sx, sy, _i, _j, _ref, _ref1;
    if (!this.loaded) {
      this.isConnected = false;
      this.camWidth = 40;
      this.camHeight = 30;
      this.size = 20;
      this.video = document.createElement('video');
      this.video.setAttribute('autoplay', 'true');
      this.video.setAttribute('width', this.camWidth);
      this.video.setAttribute('height', this.camHeight);
      this.video.id = 'videoElement';
      this.video.style.position = 'absolute';
      this.video.style.top = 0;
      this.video.style.left = 0;
      this.video.style.zIndex = 10;
      this.video.style.width = this.camWidth + 'px';
      this.video.style.height = this.camHeight + 'px';
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.camWidth);
      this.canvas.setAttribute('height', this.camHeight);
      this.canvas.style.width = this.camWidth + 'px';
      this.canvas.style.height = this.camHeight + 'px';
      this.canvas.style.position = 'absolute';
      this.canvas.style.top = 0;
      this.canvas.style.left = this.camWidth + 'px';
      this.canvas.style.zIndex = 10;
      sx = ((window.innerWidth - (this.camWidth * this.size)) * 0.5) + 16;
      sy = ((window.innerHeight - (this.camHeight * this.size)) * 0.5) + 16;
      this.sprites = [];
      for (i = _i = 0, _ref = this.camWidth; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sprites[i] = [];
        for (j = _j = 0, _ref1 = this.camHeight; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          p = new PIXI.Sprite(window.app.textures[0]);
          p.pivot.x = p.pivot.y = 16;
          p.position.x = sx + (i * this.size);
          p.position.y = sy + (j * this.size);
          p.scale.x = p.scale.y = this.size / 32;
          this.view.addChild(p);
          this.sprites[i][j] = p;
        }
      }
    }
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
    if (navigator.getUserMedia) {
      navigator.getUserMedia({
        video: true
      }, this.handleVideo, this.handleVideoError);
    }
    PictureTile.__super__.load.call(this);
    return null;
  };

  PictureTile.prototype.handleVideo = function(stream) {
    this.isConnected = true;
    this.localStream = stream;
    this.video.src = window.URL.createObjectURL(this.localStream);
    return null;
  };

  PictureTile.prototype.handleVideoError = function(error) {
    if (console) {
      console.log('ERROR :: \n' + error);
    }
    return null;
  };

  PictureTile.prototype.unload = function() {
    if (this.localStream) {
      this.isConnected = false;
      this.localStream.stop();
    }
    PictureTile.__super__.unload.call(this);
    return null;
  };

  PictureTile.prototype.update = function() {
    PictureTile.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (this.isConnected) {
      this.canvas.getContext('2d').drawImage(this.video, 0, 0, this.camWidth, this.camHeight);
      this.drawPixels();
    }
    return null;
  };

  PictureTile.prototype.resize = function() {
    return null;
  };

  PictureTile.prototype.drawPixels = function() {
    var data, hex, hsb, i, offset, rgb, sprite, x, y, _i, _ref;
    data = this.canvas.getContext('2d').getImageData(0, 0, this.camWidth, this.camHeight).data;
    x = 0;
    y = 0;
    for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 4) {
      sprite = this.sprites[x][y];
      rgb = [data[i], data[i + 1], data[i + 2]];
      hex = ColourConversion.rgbToHex(rgb);
      sprite.tint = hex;
      hsb = ColourConversion.hexToHsb(hex);
      offset = hsb[2] * 0.01;
      sprite.scale.x = sprite.scale.y = ((this.size / 32) * 1.5) * offset;
      x++;
      if (x === this.camWidth) {
        x = 0;
        y++;
      }
    }
    return null;
  };

  return PictureTile;

})(Sketch);

PlanktonTank = (function(_super) {
  __extends(PlanktonTank, _super);

  function PlanktonTank(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.resize = __bind(this.resize, this);
    this.addPlankton = __bind(this.addPlankton, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    PlanktonTank.__super__.constructor.call(this, this.renderer, this.name);
  }

  PlanktonTank.prototype.load = function() {
    if (!this.loaded) {
      this.numPlankton = 30;
      this.plankton = [];
      this.addPlankton();
    }
    PlanktonTank.__super__.load.call(this);
    return null;
  };

  PlanktonTank.prototype.unload = function() {
    PlanktonTank.__super__.unload.call(this);
    return null;
  };

  PlanktonTank.prototype.update = function() {
    var p, _i, _len, _ref;
    PlanktonTank.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.plankton;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.update();
    }
    return null;
  };

  PlanktonTank.prototype.addPlankton = function() {
    var i, p, _i, _ref;
    for (i = _i = 0, _ref = this.numPlankton; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      p = new Plankton();
      this.plankton.push(p);
      this.view.addChild(p.view);
    }
    return null;
  };

  PlanktonTank.prototype.resize = function() {
    return null;
  };

  return PlanktonTank;

})(Sketch);

Point = (function() {
  function Point(x, y, z) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    this.z = z != null ? z : 0;
    this.toString = __bind(this.toString, this);
    this.clone = __bind(this.clone, this);
  }

  Point.prototype.clone = function() {
    return new Point(this.x, this.y, this.z);
  };

  Point.prototype.toString = function() {
    return 'Point [x:' + this.x + ', y:' + this.y + ', z:' + this.z + ']';
  };

  return Point;

})();

AABB = (function() {
  function AABB(center, dimensions) {
    this.center = center;
    this.dimensions = dimensions;
    this.calculatePoints();
  }

  AABB.prototype.containsPoint = function(point) {
    if (point.x >= this.xMin && point.x <= this.xMax && point.y >= this.yMin && point.y <= this.yMax) {
      return true;
    } else {
      return false;
    }
  };

  AABB.prototype.intersectsAABB = function(box) {
    if (box.center.x < this.center.x) {
      return box.xMin <= this.xMax && box.yMin <= this.yMax && box.xMax >= this.xMin && box.yMax >= this.yMin;
    } else {
      return this.xMin <= box.xMax && this.yMin <= box.yMax && this.xMax >= box.xMin && this.yMax >= box.yMin;
    }
  };

  AABB.prototype.setCenter = function(center) {
    this.center = center;
    return this.calculatePoints();
  };

  AABB.prototype.setDimensions = function(dimensions) {
    this.dimensions = dimensions;
    return this.calculatePoints();
  };

  AABB.prototype.calculatePoints = function() {
    this.xMin = this.center.x - (this.dimensions.x * 0.5);
    this.xMax = this.center.x + (this.dimensions.x * 0.5);
    this.yMin = this.center.y - (this.dimensions.y * 0.5);
    this.yMax = this.center.y + (this.dimensions.y * 0.5);
    this.points = [];
    this.points.push(new Point(this.xMin, this.yMin));
    this.points.push(new Point(this.xMax, this.yMin));
    this.points.push(new Point(this.xMax, this.yMax));
    this.points.push(new Point(this.xMin, this.yMax));
    return null;
  };

  return AABB;

})();

QuadTree = (function() {
  QuadTree.TOP_LEFT = 0;

  QuadTree.TOP_RIGHT = 1;

  QuadTree.BOTTOM_LEFT = 2;

  QuadTree.BOTTOM_RIGHT = 3;

  function QuadTree(boundsAABB, maxCapacity, maxLevels, level) {
    this.boundsAABB = boundsAABB;
    this.maxCapacity = maxCapacity != null ? maxCapacity : 1;
    this.maxLevels = maxLevels != null ? maxLevels : 10;
    this.level = level != null ? level : 0;
    this.points = [];
    this.children = [];
  }

  QuadTree.prototype.insert = function(aabb) {
    var i, index;
    if (this.children.length > 0) {
      index = this.getIndex(aabb);
      if (index !== -1) {
        this.children[index].insert(aabb);
        return;
      }
    }
    this.points.push(aabb);
    if (this.points.length > this.maxCapacity && this.level < this.maxLevels) {
      if (this.children.length === 0) {
        this.subdivide();
      }
      i = 0;
      while (i < this.points.length) {
        index = this.getIndex(this.points[i]);
        if (index !== -1) {
          this.children[index].insert(this.points.splice(i, 1)[0]);
        } else {
          i++;
        }
      }
    }
    return null;
  };

  QuadTree.prototype.subdivide = function() {
    var ct, dims, halfHeight, halfWidth, nextLevel;
    halfWidth = this.boundsAABB.dimensions.x * 0.5;
    halfHeight = this.boundsAABB.dimensions.y * 0.5;
    dims = new Point(halfWidth, halfHeight);
    nextLevel = this.level + 1;
    ct = new Point(this.boundsAABB.xMin + (halfWidth * 0.5), this.boundsAABB.yMin + (halfHeight * 0.5));
    this.tl = new QuadTree(new AABB(ct, dims), this.maxCapacity, this.maxLevels, nextLevel);
    ct = new Point((this.boundsAABB.xMin + halfWidth) + (halfWidth * 0.5), this.boundsAABB.yMin + (halfHeight * 0.5));
    this.tr = new QuadTree(new AABB(ct, dims), this.maxCapacity, this.maxLevels, nextLevel);
    ct = new Point(this.boundsAABB.xMin + (halfWidth * 0.5), (this.boundsAABB.yMin + halfHeight) + (halfHeight * 0.5));
    this.bl = new QuadTree(new AABB(ct, dims), this.maxCapacity, this.maxLevels, nextLevel);
    ct = new Point((this.boundsAABB.xMin + halfWidth) + (halfWidth * 0.5), (this.boundsAABB.yMin + halfHeight) + (halfHeight * 0.5));
    this.br = new QuadTree(new AABB(ct, dims), this.maxCapacity, this.maxLevels, nextLevel);
    this.children = [this.tl, this.tr, this.bl, this.br];
    return null;
  };

  QuadTree.prototype.getIndex = function(aabb) {
    var botQuad, index, topQuad;
    index = -1;
    topQuad = aabb.center.y > this.boundsAABB.yMin && aabb.center.y <= this.boundsAABB.center.y;
    botQuad = aabb.center.y > this.boundsAABB.center.y && aabb.center.y <= this.boundsAABB.yMax;
    if (aabb.center.x > this.boundsAABB.xMin && aabb.center.x <= this.boundsAABB.center.x) {
      if (topQuad) {
        index = 0;
      } else if (botQuad) {
        index = 2;
      }
    } else if (aabb.center.x > this.boundsAABB.center.x && aabb.center.x <= this.boundsAABB.xMax) {
      if (topQuad) {
        index = 1;
      } else if (botQuad) {
        index = 3;
      }
    }
    return index;
  };

  QuadTree.prototype.retrieve = function(aabb) {
    var arr, child, index, _i, _len, _ref;
    index = this.getIndex(aabb);
    arr = this.points;
    if (this.children.length > 0) {
      if (index !== -1) {
        arr = arr.concat(this.children[index].retrieve(aabb));
      } else {
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          arr = arr.concat(child.retrieve(aabb));
        }
      }
    }
    return arr;
  };

  QuadTree.prototype.clear = function() {
    var child, _i, _len, _ref;
    this.points = [];
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      child.clear();
    }
    this.children = [];
    return null;
  };

  return QuadTree;

})();

QuadTreeTest = (function(_super) {
  __extends(QuadTreeTest, _super);

  function QuadTreeTest(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.getColour = __bind(this.getColour, this);
    this.circleFill = __bind(this.circleFill, this);
    this.colourTree = __bind(this.colourTree, this);
    this.drawTree = __bind(this.drawTree, this);
    this.generateNewMap = __bind(this.generateNewMap, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    QuadTreeTest.__super__.constructor.call(this, this.renderer, this.name);
    this.numPoints = 20;
    this.points = [];
    this.pointSprites = [];
    this.deadSprites = [];
  }

  QuadTreeTest.prototype.load = function() {
    var circle, size,
      _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.moving = true;
      this.render = false;
      this.circles = false;
      this.childless = false;
      circle = new PIXI.Graphics();
      circle.beginFill(0xf3f3f3);
      circle.drawCircle(0, 0, 5);
      circle.endFill();
      this.circleTex = circle.generateTexture();
      this.canvasHolder = new PIXI.DisplayObjectContainer();
      this.view.addChild(this.canvasHolder);
      this.canvas = new PIXI.Graphics();
      this.canvasHolder.addChild(this.canvas);
      this.pointHolder = new PIXI.DisplayObjectContainer();
      this.pointHolder.alpha = 0;
      this.view.addChild(this.pointHolder);
      size = Math.min(window.innerWidth - 50, window.innerHeight - 50);
      this.bounds = new AABB(new Point(window.innerWidth * 0.5, window.innerHeight * 0.5), new Point(size, size));
      this.tree = new QuadTree(this.bounds, 1, 10, 0);
      this.gui.add(this, 'moving').name('Motion On').listen();
      this.gui.add(this, 'render').name('Colour Fill').listen();
      this.gui.add(this, 'circles').name('Circles').listen();
      this.gui.add(this, 'childless').name('Only Smallest').listen();
      this.gui.add(this, 'numPoints', 2, 1000, 1).name('Points').onChange(function() {
        if (_this.numPoints > 225 && _this.moving) {
          return _this.moving = false;
        }
      });
      this.gui.add(this, 'generateNewMap').name('Generate');
      this.gui.add(this.pointHolder, 'alpha', 0, 1).name('Points Alpha');
      this.renderSprite = new PIXI.Sprite(this.canvasHolder.generateTexture());
      this.canvasHolder.addChild(this.renderSprite);
      this.renderSprite.alpha = 0;
      this.canvasHolder.addChild(this.canvas);
    }
    this.waiting = false;
    this.generateNewMap();
    QuadTreeTest.__super__.load.call(this);
    return null;
  };

  QuadTreeTest.prototype.unload = function() {
    QuadTreeTest.__super__.unload.call(this);
    return null;
  };

  QuadTreeTest.prototype.update = function() {
    var i, nx, ny, pt, _i, _len, _ref;
    QuadTreeTest.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.mousePressed && !this.waiting) {
      this.waiting = true;
    } else if (!window.app.mousePressed && this.waiting) {
      this.waiting = false;
      this.generateNewMap();
    }
    if (this.moving) {
      i = 0;
      this.tree.clear();
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pt = _ref[_i];
        nx = pt.center.x + pt.velocity.x;
        ny = pt.center.y + pt.velocity.y;
        if (nx > this.bounds.xMax) {
          nx -= this.bounds.dimensions.x;
        } else if (nx < this.bounds.xMin) {
          nx += this.bounds.dimensions.x;
        }
        if (ny > this.bounds.yMax) {
          ny -= this.bounds.dimensions.y;
        } else if (ny < this.bounds.yMin) {
          ny += this.bounds.dimensions.y;
        }
        pt.setCenter(new Point(nx, ny));
        this.pointSprites[i].position.x = nx;
        this.pointSprites[i].position.y = ny;
        i++;
        this.tree.insert(pt);
      }
      this.canvas.clear();
      if (this.circles) {
        this.renderSprite.alpha = 1;
        this.circleFill(this.tree);
      } else {
        this.renderSprite.alpha = 0;
        this.drawTree(this.tree);
      }
    }
    if (this.render) {
      this.renderSprite.alpha = 0;
      this.canvas.lineStyle(null);
      this.colourTree(this.tree);
      this.render = false;
    }
    if (this.circles && !this.moving) {
      this.canvas.clear();
      this.renderSprite.alpha = 1;
      this.renderSprite.setTexture(this.canvasHolder.generateTexture());
      this.circleFill(this.tree);
      this.circles = false;
    }
    return null;
  };

  QuadTreeTest.prototype.resize = function() {
    return null;
  };

  QuadTreeTest.prototype.generateNewMap = function() {
    var i, pt, sp, _i, _j, _len, _ref, _ref1;
    if (this.pointSprites.length > 0) {
      for (i = _i = _ref = this.pointSprites.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        sp = this.pointSprites[i];
        this.pointSprites.splice(i, 1);
        this.deadSprites.push(sp);
        this.pointHolder.removeChild(sp);
      }
    }
    this.tree.clear();
    this.generatePoints();
    this.addPointSprites();
    _ref1 = this.points;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      pt = _ref1[_j];
      this.tree.insert(pt);
    }
    this.renderSprite.alpha = 0;
    this.canvas.clear();
    this.drawTree(this.tree);
    return null;
  };

  QuadTreeTest.prototype.drawTree = function(tree) {
    var child, _i, _len, _ref;
    this.canvas.lineStyle(1, 0xF3F3F3);
    this.canvas.drawRect(tree.boundsAABB.xMin, tree.boundsAABB.yMin, tree.boundsAABB.dimensions.x, tree.boundsAABB.dimensions.y);
    _ref = tree.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      this.drawTree(child);
    }
    return null;
  };

  QuadTreeTest.prototype.colourTree = function(tree) {
    var child, hex, _i, _len, _ref;
    if (tree.children.length === 0 || !this.childless) {
      hex = this.getColour(tree);
      this.canvas.beginFill(hex);
      this.canvas.drawRect(tree.boundsAABB.xMin, tree.boundsAABB.yMin, tree.boundsAABB.dimensions.x, tree.boundsAABB.dimensions.y);
      this.canvas.endFill();
    }
    _ref = tree.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      this.colourTree(child);
    }
    return null;
  };

  QuadTreeTest.prototype.circleFill = function(tree) {
    var child, hex, _i, _len, _ref;
    hex = this.getColour(tree);
    if (tree.children.length === 0 || !this.childless) {
      this.canvas.clear();
      this.canvas.lineStyle(1, hex);
      this.canvas.drawCircle(tree.boundsAABB.center.x, tree.boundsAABB.center.y, tree.boundsAABB.dimensions.x * 0.5);
      this.renderSprite.setTexture(this.canvasHolder.generateTexture());
    }
    _ref = tree.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      this.circleFill(child);
    }
    return null;
  };

  QuadTreeTest.prototype.getColour = function(tree) {
    var angDeg, angRad, br, dist, sat, xd, yd;
    xd = tree.boundsAABB.center.x - this.bounds.center.x;
    yd = tree.boundsAABB.center.y - this.bounds.center.y;
    dist = Math.sqrt((xd * xd) + (yd * yd));
    angRad = Math.atan2(yd, xd);
    angDeg = MathUtils.radToDeg(angRad);
    if (angDeg < 0) {
      angDeg += 360;
    }
    sat = 10 + (90 * (dist / this.bounds.dimensions.x));
    br = 100 - (70 * (tree.boundsAABB.dimensions.x / this.bounds.dimensions.x));
    return ColourConversion.hsbToHex([angDeg, sat, br]);
  };

  QuadTreeTest.prototype.generatePoints = function() {
    var i, p, tx, ty, _i, _ref;
    this.points = [];
    for (i = _i = 0, _ref = this.numPoints; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      tx = this.bounds.xMin + (Math.random() * this.bounds.dimensions.x);
      ty = this.bounds.yMin + (Math.random() * this.bounds.dimensions.y);
      p = new AABB(new Point(tx, ty), new Point(10, 10));
      this.points.push(p);
      p.velocity = {
        x: -2 + (Math.random() * 4),
        y: -2 + (Math.random() * 4)
      };
    }
    return null;
  };

  QuadTreeTest.prototype.addPointSprites = function() {
    var p, sp, _i, _len, _ref, _results;
    this.pointSprites = [];
    _ref = this.points;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (this.deadSprites.length === 0) {
        sp = new PIXI.Sprite(this.circleTex);
        sp.anchor.x = sp.anchor.y = 0.5;
      } else {
        sp = this.deadSprites[0];
        this.deadSprites.splice(0, 1);
      }
      sp.position.x = p.center.x;
      sp.position.y = p.center.y;
      this.pointHolder.addChild(sp);
      _results.push(this.pointSprites.push(sp));
    }
    return _results;
  };

  return QuadTreeTest;

})(Sketch);

Radar = (function(_super) {
  __extends(Radar, _super);

  Radar.prototype.numSprites = 60;

  Radar.prototype.radarWidth = 579;

  Radar.prototype.minScale = 0.1;

  Radar.prototype.maxScale = 0.3;

  Radar.prototype.rotation = 0;

  Radar.prototype.rotationSpeed = 238;

  Radar.prototype.midX = 400;

  Radar.prototype.midY = 300;

  Radar.prototype.sprites = [];

  function Radar(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.createSprites = __bind(this.createSprites, this);
    this.scaleSprites = __bind(this.scaleSprites, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Radar.__super__.constructor.call(this, this.renderer, this.name);
    this.midX = window.innerWidth * 0.5;
    this.midY = window.innerHeight * 0.5;
  }

  Radar.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.gui.add(this, 'rotationSpeed', 0.1, 359.9);
      this.gui.add(this, 'radarWidth', 10, 1000);
      this.gui.add(this, 'minScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.gui.add(this, 'maxScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.holder = new PIXI.DisplayObjectContainer();
      this.renderTexture = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderTexture2 = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.dummy = new PIXI.Graphics();
      this.dummy.beginFill(0x000000, 0.05);
      this.dummy.drawRect(0, 0, window.innerWidth, window.innerHeight);
      this.currentTexture = this.renderTexture;
      this.canvas = new PIXI.Sprite(this.currentTexture);
      this.holder.addChild(this.canvas);
      this.view.addChild(this.holder);
      this.createSprites();
    }
    Radar.__super__.load.call(this);
    return null;
  };

  Radar.prototype.unload = function() {
    Radar.__super__.unload.call(this);
    return null;
  };

  Radar.prototype.update = function() {
    var i, rot, temp, _i, _ref;
    Radar.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.rotation += this.rotationSpeed;
    rot = MathUtils.degToRad(this.rotation);
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = this.sprites[i];
      this.sprite.position.x = this.midX + (Math.cos(rot) * ((this.radarWidth / this.numSprites) * i));
      this.sprite.position.y = this.midY + (Math.sin(rot) * ((this.radarWidth / this.numSprites) * i));
    }
    temp = this.renderTexture;
    this.renderTexture = this.renderTexture2;
    this.renderTexture2 = temp;
    this.canvas.setTexture(this.renderTexture);
    this.renderTexture2.render(this.holder, new PIXI.Point(0, 0), false);
    this.renderTexture2.render(this.dummy, new PIXI.Point(0, 0), false);
    return null;
  };

  Radar.prototype.resize = function() {
    return null;
  };

  Radar.prototype.scaleSprites = function() {
    var i, tgtScale, _i, _ref;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      tgtScale = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      TweenMax.to(this.sprites[i].scale, 2, {
        x: tgtScale,
        y: tgtScale,
        ease: Bounce.easeOut
      });
    }
    return null;
  };

  Radar.prototype.createSprites = function() {
    var i, rot, rotInc, _i, _ref;
    rotInc = 360 / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.sprite.scale.x = this.sprite.scale.y = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      rot = MathUtils.degToRad(i * rotInc);
      this.sprite.position.x = this.midX + ((this.radarWidth / this.numSprites) * i);
      this.sprite.position.y = this.midY;
      this.holder.addChild(this.sprite);
      this.sprites.push(this.sprite);
    }
    return null;
  };

  return Radar;

})(Sketch);

Ribbon = (function(_super) {
  __extends(Ribbon, _super);

  function Ribbon(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.drawRibbon = __bind(this.drawRibbon, this);
    this.updateTrails = __bind(this.updateTrails, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Ribbon.__super__.constructor.call(this, this.renderer, this.name);
  }

  Ribbon.prototype.load = function() {
    if (!this.loaded) {
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 2.9;
      this.baseNode.yIncrement = 3.7;
      this.baseNode.xOffset = 470;
      this.baseNode.yOffset = 220;
      this.ribbonWidth = 200;
      this.trailLength = 60;
      this.tailColour = 0xFFFFFF;
      this.nodeA = new Node(this.baseNode.position.x, this.baseNode.position.y - this.ribbonWidth);
      this.nodeB = new Node(this.baseNode.position.x, this.baseNode.position.y + this.ribbonWidth);
      this.nodeA.recordedPositions = this.nodeB.recordedPositions = this.trailLength;
      this.nodeA.fillPositions();
      this.nodeB.fillPositions();
      this.nodeA.sin = 0;
      this.nodeB.sin = 0;
      this.nodeA.inc = 4.6;
      this.nodeB.inc = 3.2;
      this.graphics = new PIXI.Graphics();
      this.tailA = [];
      this.tailB = [];
      this.view.addChild(this.graphics);
      this.makeGui();
      this.gui.add(this, 'ribbonWidth', 1, 200);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
      this.gui.add(this.nodeA, 'inc', 0.1, 359.9);
      this.gui.add(this.nodeB, 'inc', 0.1, 359.9);
    }
    Ribbon.__super__.load.call(this);
    return null;
  };

  Ribbon.prototype.unload = function() {
    Ribbon.__super__.unload.call(this);
    return null;
  };

  Ribbon.prototype.update = function() {
    var ty;
    Ribbon.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(MathUtils.degToRad(this.baseNode.xSin)) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(MathUtils.degToRad(this.baseNode.ySin)) * this.baseNode.yOffset);
    this.nodeA.sin += this.nodeA.inc;
    this.nodeA.sin %= 360;
    ty = this.baseNode.position.y - (Math.sin(MathUtils.degToRad(this.nodeA.sin)) * this.ribbonWidth);
    this.nodeA.moveTo(this.baseNode.position.x, ty);
    this.nodeB.sin += this.nodeB.inc;
    this.nodeB.sin %= 360;
    ty = this.baseNode.position.y + (Math.sin(MathUtils.degToRad(this.nodeB.sin)) * this.ribbonWidth);
    this.nodeB.moveTo(this.baseNode.position.x, ty);
    this.drawRibbon();
    return null;
  };

  Ribbon.prototype.resize = function() {
    return null;
  };

  Ribbon.prototype.updateTrails = function() {
    var i, sp, _i, _ref;
    for (i = _i = 0, _ref = this.trailLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      sp = this.tailA[i];
      sp.position.x = this.nodeA.positions[i].x;
      sp.position.y = this.nodeA.positions[i].y;
      sp = this.tailB[i];
      sp.position.x = this.nodeB.positions[i].x;
      sp.position.y = this.nodeB.positions[i].y;
    }
    return null;
  };

  Ribbon.prototype.drawRibbon = function() {
    var i, inc, pt1, pt2, pt3, pt4, _i, _ref;
    this.graphics.clear();
    inc = 1 / this.trailLength;
    for (i = _i = 0, _ref = this.trailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      pt1 = this.nodeA.positions[i];
      pt2 = this.nodeB.positions[i];
      pt3 = this.nodeA.positions[i + 1];
      pt4 = this.nodeB.positions[i + 1];
      this.graphics.beginFill(this.tailColour, i * inc);
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt3.x, pt3.y);
      this.graphics.lineTo(pt4.x, pt4.y);
      this.graphics.lineTo(pt2.x, pt2.y);
      this.graphics.endFill();
    }
    return null;
  };

  return Ribbon;

})(Sketch);

ShapeShifter = (function(_super) {
  __extends(ShapeShifter, _super);

  function ShapeShifter(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.placeNodes = __bind(this.placeNodes, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    ShapeShifter.__super__.constructor.call(this, this.renderer, this.name);
  }

  ShapeShifter.prototype.load = function() {
    var f, key, node, _ref,
      _this = this;
    if (!this.loaded) {
      this.holder = new PIXI.DisplayObjectContainer();
      this.holder.position.x = window.innerWidth * 0.5;
      this.holder.position.y = window.innerHeight * 0.5;
      this.view.addChild(this.holder);
      this.shapes = ['cube', 'cylinder', 'torus', 'sphere', 'sphere2', 'cone'];
      this.curShape = 0;
      this.size = 10;
      this.spacing = 32;
      this.xOffset = 0;
      this.yOffset = 0;
      this.isometricScale = 1;
      this.focalLength = 70;
      this.cameraPosition = 1000;
      this.depthOn = false;
      this.perspectiveOn = true;
      this.numNodes = this.size * this.size * this.size;
      this.nodes = this.createNodes();
      this.sprites = this.createSprites();
      this.placeSprites();
      this.makeGui();
      this.gui.add(this, 'depthOn').listen().onFinishChange(function() {
        if (_this.depthOn && _this.perspectiveOn) {
          return _this.perspectiveOn = false;
        }
      }).name('Isometric');
      f = this.gui.addFolder('Isometric Controls');
      f.add(this, 'isometricScale', 1, 3).name('Zoom');
      this.gui.add(this, 'perspectiveOn').listen().onFinishChange(function() {
        if (_this.depthOn && _this.perspectiveOn) {
          return _this.depthOn = false;
        }
      }).name('Perspective');
      f = this.gui.addFolder('Perspective Controls');
      f.add(this, 'focalLength', 1, 300).name('Focal Length');
      f.add(this, 'cameraPosition', 0, 2000).name('Z position');
    }
    _ref = this.nodes;
    for (key in _ref) {
      node = _ref[key];
      node.position.x = node.position.y = node.position.z = 0;
    }
    TweenMax.to(this, 0.75, {
      onComplete: this.placeNodes
    });
    ShapeShifter.__super__.load.call(this);
    return null;
  };

  ShapeShifter.prototype.unload = function() {
    ShapeShifter.__super__.unload.call(this);
    return null;
  };

  ShapeShifter.prototype.update = function() {
    var h, hh, hw, w;
    ShapeShifter.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.mousePressed) {
      window.app.mousePressed = false;
      this.placeNodes();
    }
    w = window.innerWidth;
    h = window.innerHeight;
    hw = window.innerWidth * 0.5;
    hh = window.innerHeight * 0.5;
    this.xOffset = ((window.app.pointerPosition.x - hw) / w) * 360;
    this.yOffset = ((window.app.pointerPosition.y - hh) / h) * 360;
    this.placeSprites();
    return null;
  };

  ShapeShifter.prototype.resize = function() {
    return null;
  };

  ShapeShifter.prototype.createNodes = function() {
    var halfSpace, i, n, nodes, x, y, z, _i, _ref;
    nodes = {};
    x = y = z = 0;
    halfSpace = (this.spacing * this.size) * 0.5;
    for (i = _i = 0, _ref = this.numNodes; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = new Node();
      nodes[x + '_' + y + '_' + z] = n;
      x++;
      if (x === this.size) {
        x = 0;
        y++;
        if (y === this.size) {
          y = 0;
          z++;
        }
      }
    }
    return nodes;
  };

  ShapeShifter.prototype.placeNodes = function() {
    var angle, angle2, ct, curHeight, halfSpace, height, i, inc, incInc, node, outerAngle, outerRadius, radius, tubeAngle, tubeRadius, x, y, z, _i, _j, _k, _ref, _ref1, _ref2, _x, _y, _z;
    halfSpace = (this.spacing * this.size) * 0.5;
    i = 0;
    inc = 360 / this.size;
    incInc = 360 / (this.size * this.size);
    for (x = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      for (y = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        for (z = _k = 0, _ref2 = this.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
          node = this.nodes[x + '_' + y + '_' + z];
          if (this.shapes[this.curShape] === 'cube') {
            _x = (x * this.spacing) - halfSpace;
            _y = (y * this.spacing) - halfSpace;
            _z = (z * this.spacing) - halfSpace;
          } else if (this.shapes[this.curShape] === 'cylinder') {
            ct = (this.size * x) + y;
            angle = MathUtils.degToRad(ct * incInc);
            radius = halfSpace * (z / this.size);
            _x = Math.cos(angle) * radius;
            _y = (y * this.spacing) - halfSpace;
            _z = Math.sin(angle) * radius;
          } else if (this.shapes[this.curShape] === 'torus') {
            ct = (this.size * x) + y;
            outerAngle = MathUtils.degToRad(ct * incInc);
            tubeAngle = MathUtils.degToRad(z * inc);
            outerRadius = 128;
            tubeRadius = 64;
            _x = (outerRadius + (tubeRadius * Math.cos(tubeAngle))) * Math.cos(outerAngle);
            _z = (outerRadius + (tubeRadius * Math.cos(tubeAngle))) * Math.sin(outerAngle);
            _y = Math.sin(tubeAngle) * tubeRadius;
          } else if (this.shapes[this.curShape] === 'sphere') {
            ct = (this.size * x) + y;
            angle = MathUtils.degToRad(ct * incInc);
            angle2 = MathUtils.degToRad(z * inc) * 0.5;
            radius = 128;
            _z = radius * Math.cos(angle) * Math.sin(angle2);
            _y = radius * Math.sin(angle) * Math.sin(angle2);
            _x = radius * Math.cos(angle2);
          } else if (this.shapes[this.curShape] === 'sphere2') {
            angle = MathUtils.degToRad(y * inc);
            angle2 = MathUtils.degToRad(z * inc) * 0.5;
            radius = (128 / this.size) * x;
            _x = radius * Math.cos(angle) * Math.sin(angle2);
            _z = radius * Math.sin(angle) * Math.sin(angle2);
            _y = radius * Math.cos(angle2);
          } else if (this.shapes[this.curShape] === 'cone') {
            ct = (this.size * x) + z;
            angle = MathUtils.degToRad(ct * incInc);
            height = 128;
            curHeight = (y / this.size) * height;
            radius = halfSpace;
            _x = (radius * Math.cos(angle)) * ((height - curHeight) / height);
            _y = -(curHeight - (height * 0.5));
            _z = (radius * Math.sin(angle)) * ((height - curHeight) / height);
          }
          TweenMax.killTweensOf(node.position);
          TweenMax.to(node.position, 1.5, {
            x: _x,
            y: _y,
            z: _z,
            ease: Elastic.easeOut,
            delay: Math.random() * 0.2
          });
          i++;
        }
      }
    }
    this.curShape++;
    if (this.curShape === this.shapes.length) {
      this.curShape = 0;
    }
    return null;
  };

  ShapeShifter.prototype.createSprites = function() {
    var i, sp, sprites, _i, _ref;
    sprites = [];
    for (i = _i = 0, _ref = this.numNodes; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      sp = new PIXI.Sprite(window.app.textures[0]);
      sp.pivot.x = sp.pivot.y = 16;
      this.holder.addChild(sp);
      sprites.push(sp);
    }
    return sprites;
  };

  ShapeShifter.prototype.placeSprites = function() {
    var div, i, max, min, node, scalar, sp, x, y, z, _i, _j, _k, _ref, _ref1, _ref2;
    i = 0;
    min = Math.log(0.1);
    max = Math.log(1);
    for (x = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      for (y = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        for (z = _k = 0, _ref2 = this.size; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
          sp = this.sprites[i];
          node = this.nodes[x + '_' + y + '_' + z];
          scalar = 0;
          if (this.depthOn) {
            scalar = node.position.z / (this.spacing * this.size);
            sp.scale.x = sp.scale.y = (1 + Math.exp(min + scalar)) * this.isometricScale;
            sp.position.x = (node.position.x * sp.scale.x) + (scalar * this.xOffset);
            sp.position.y = (node.position.y * sp.scale.y) + (scalar * this.yOffset);
          } else if (this.perspectiveOn) {
            div = this.focalLength + (node.position.z - this.cameraPosition);
            if (div !== 0) {
              scalar = this.focalLength / div;
            } else {
              scalar = 0;
            }
            sp.scale.x = sp.scale.y = 10 * scalar;
            sp.position.x = (node.position.x - this.xOffset) * (scalar * 10);
            sp.position.y = -(node.position.y - this.yOffset) * (scalar * 10);
          } else {
            sp.scale.x = sp.scale.y = 1;
            sp.position.x = node.position.x;
            sp.position.y = node.position.y;
          }
          sp.alpha = 0.4;
          i++;
        }
      }
    }
    return null;
  };

  return ShapeShifter;

})(Sketch);

SineWave = (function(_super) {
  __extends(SineWave, _super);

  SineWave.id = 'Sine Wave';

  SineWave.prototype.phase = 0;

  SineWave.prototype.limit = 360;

  SineWave.prototype.waveLength = 203;

  SineWave.prototype.amplitude = 260;

  SineWave.prototype.frequency = 10;

  SineWave.prototype.rotateAngle = 0;

  SineWave.prototype.rotateSpeed = 351.16;

  SineWave.prototype.numSprites = 100;

  SineWave.prototype.midY = 0;

  SineWave.prototype.sprites = [];

  function SineWave(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.createSprites = __bind(this.createSprites, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    SineWave.__super__.constructor.call(this, this.renderer, this.name);
  }

  SineWave.prototype.load = function() {
    this.midY = window.innerHeight * 0.5;
    this.midX = window.innerWidth * 0.5;
    if (!this.loaded) {
      this.createSprites();
      this.makeGui();
      this.gui.add(this, 'waveLength', 10, 1000);
      this.gui.add(this, 'amplitude', 10, 500);
      this.gui.add(this, 'frequency', 1, 100);
      this.gui.add(this, 'limit', 1, 360);
      this.gui.add(this, 'rotateSpeed', 0, 720);
      this.gui.close();
    }
    SineWave.__super__.load.call(this);
    return null;
  };

  SineWave.prototype.unload = function() {
    SineWave.__super__.unload.call(this);
    return null;
  };

  SineWave.prototype.update = function() {
    var angle, i, newx, newy, sp, spacing, xCalc, xPos, xSin, yCalc, yPos, _i, _ref;
    SineWave.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = this.sprites[i];
      xPos = (i * spacing) + ((this.phase / 360) * this.waveLength);
      xSin = ((xPos % this.waveLength) / this.waveLength) * 360;
      yPos = this.midY + (Math.sin(MathUtils.degToRad(xSin)) * this.amplitude);
      xCalc = xPos - this.midX;
      yCalc = yPos - this.midY;
      angle = MathUtils.degToRad(this.rotateAngle);
      newx = (xCalc * Math.cos(angle)) - (yCalc * Math.sin(angle));
      newy = (xCalc * Math.sin(angle)) + (yCalc * Math.cos(angle));
      sp.position.x = this.midX + newx;
      sp.position.y = this.midY + newy;
    }
    this.phase += this.frequency;
    this.phase %= this.limit;
    this.rotateAngle += this.rotateSpeed;
    this.rotateAngle %= 360;
    return null;
  };

  SineWave.prototype.createSprites = function() {
    var i, sp, spacing, _i, _ref;
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(window.app.textures[0]);
      sp.pivot.x = sp.pivot.y = 16;
      sp.position.x = i * spacing;
      sp.position.y = this.midY;
      this.sprites.push(sp);
      this.view.addChild(sp);
    }
    return null;
  };

  return SineWave;

})(Sketch);

Plankton = (function(_super) {
  __extends(Plankton, _super);

  function Plankton() {
    this.drawLimbs = __bind(this.drawLimbs, this);
    this.newDirection = __bind(this.newDirection, this);
    this.updateTail = __bind(this.updateTail, this);
    this.update = __bind(this.update, this);
    var hex, hsb;
    Plankton.__super__.constructor.call(this, Math.random() * window.innerWidth, Math.random() * window.innerHeight, 0);
    this.view = new PIXI.DisplayObjectContainer();
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.gut = new PIXI.Sprite(window.app.textures[0]);
    this.gut.pivot.x = this.gut.pivot.y = 16;
    hsb = [Math.random() * 360, 100, 100];
    hex = ColourConversion.hsbToHex(hsb);
    this.gut.tint = hex;
    this.view.addChild(this.gut);
    this.angle = 0;
    this.newDirection();
    this.tailProps = {
      min: 18,
      max: 32,
      dir: -1,
      dist: 0
    };
    this.tailProps.dist = this.tailProps.min + (Math.random() * (this.tailProps.max - this.tailProps.min));
    this.tailProps.inSpeed = 0.95 + (Math.random() * 0.04);
    this.tailProps.outSpeed = 1.05 + (Math.random() * 0.14);
    this.tailProps.accel = 0.7 + (Math.random() * 1);
    this.tailProps.decel = 0.85 + (Math.random() * 0.1);
    this.view.scale.x = this.view.scale.y = this.tailProps.decel;
    this.tail = new PIXI.Sprite(window.app.textures[0]);
    this.tail.pivot.x = this.tail.pivot.y = 16;
    this.tail.scale.x = this.tail.scale.y = 0.5;
    this.tail.position.y = this.tailProps.dist;
    this.view.addChild(this.tail);
    this.tailRight = new PIXI.Sprite(window.app.textures[0]);
    this.tailRight.pivot.x = this.tailRight.pivot.y = 16;
    this.tailRight.scale.x = this.tailRight.scale.y = 0.25;
    this.tailRight.position.y = this.tailProps.dist;
    this.tailRight.position.x = this.tailProps.dist;
    this.view.addChild(this.tailRight);
    this.tailLeft = new PIXI.Sprite(window.app.textures[0]);
    this.tailLeft.pivot.x = this.tailLeft.pivot.y = 16;
    this.tailLeft.scale.x = this.tailLeft.scale.y = 0.25;
    this.tailLeft.position.y = this.tailProps.dist;
    this.tailLeft.position.x = -this.tailProps.dist;
    this.view.addChild(this.tailLeft);
  }

  Plankton.prototype.update = function() {
    var cos, sin, vx, vy;
    this.graphics.clear();
    this.updateTail();
    this.drawLimbs();
    if (this.tailProps.dir === 1) {
      sin = Math.sin(MathUtils.degToRad(this.angle));
      cos = Math.cos(MathUtils.degToRad(this.angle));
      vx = (-sin * 1) * this.tailProps.accel;
      vy = (cos * 1) * this.tailProps.accel;
      this.velocity.x += vx;
      this.velocity.y += vy;
    } else {
      this.velocity.x *= this.tailProps.decel;
      this.velocity.y *= this.tailProps.decel;
    }
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
    if (this.position.y < -100) {
      this.position.y += window.innerHeight + 200;
    } else if (this.position.y > window.innerHeight + 100) {
      this.position.y -= window.innerHeight + 200;
    }
    if (this.position.x < -100) {
      this.position.x += window.innerWidth + 200;
    } else if (this.position.x > window.innerWidth + 100) {
      this.position.x -= window.innerWidth + 200;
    }
    this.view.position.x = this.position.x;
    this.view.position.y = this.position.y;
    this.view.rotation = MathUtils.degToRad(this.angle + 180);
    return null;
  };

  Plankton.prototype.updateTail = function() {
    var cos, nx, ny, sin;
    if (this.tailProps.dir === -1) {
      this.tailProps.dist *= this.tailProps.inSpeed;
      if (this.tailProps.dist < this.tailProps.min) {
        this.tailProps.dir *= -1;
      }
    } else {
      this.tailProps.dist *= this.tailProps.outSpeed;
      if (this.tailProps.dist > this.tailProps.max) {
        this.tailProps.dir *= -1;
      }
    }
    this.tail.position.y = this.tailProps.dist;
    sin = Math.sin(MathUtils.degToRad(30));
    cos = Math.cos(MathUtils.degToRad(30));
    nx = -sin * this.tailProps.dist;
    ny = cos * this.tailProps.dist;
    this.tailLeft.position.x = nx;
    this.tailLeft.position.y = ny;
    sin = Math.sin(MathUtils.degToRad(-30));
    cos = Math.cos(MathUtils.degToRad(-30));
    nx = -sin * this.tailProps.dist;
    ny = cos * this.tailProps.dist;
    this.tailRight.position.x = nx;
    this.tailRight.position.y = ny;
    return null;
  };

  Plankton.prototype.newDirection = function() {
    var newAngle, time,
      _this = this;
    TweenMax.killTweensOf(this);
    newAngle = Math.random() * 360;
    time = 0.5 + (3 * Math.random());
    TweenMax.to(this, time, {
      angle: newAngle,
      onComplete: function() {
        return _this.newDirection();
      }
    });
    return null;
  };

  Plankton.prototype.drawLimbs = function() {
    this.graphics.lineStyle(1, 0xFFd0d0, 0.9);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tail.position.x, this.tail.position.y);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tailRight.position.x, this.tailRight.position.y);
    this.graphics.moveTo(this.gut.position.x, this.gut.position.y);
    this.graphics.lineTo(this.tailLeft.position.x, this.tailLeft.position.y);
    return null;
  };

  return Plankton;

})(Node);

SpirographNode = (function(_super) {
  __extends(SpirographNode, _super);

  function SpirographNode(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.drawTrails = __bind(this.drawTrails, this);
    this.updateTint = __bind(this.updateTint, this);
    this.update = __bind(this.update, this);
    this.randomise = __bind(this.randomise, this);
    SpirographNode.__super__.constructor.call(this, x, y, z);
    this.midX = window.innerWidth * 0.5;
    this.midY = window.innerHeight * 0.5;
    this.sin = 0;
    this.speed = 1;
    this.radSin = 0;
    this.radSpeed = 10;
    this.radMin = 180;
    this.radMax = 260;
    this.tailWidth = 3;
    this.color = 120;
    this.colorSpeed = 0;
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.recordedPositions = 90;
    this.positions = [];
    this.fillPositions();
    this.view = new PIXI.DisplayObjectContainer;
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.randomSpeeds = [0.1, 1.1, 59.9, 60.4, 120.1, 180.6, 240.2, 300.1, 75.5, 25.2];
    this.randomSmallRads = [0, 30, 60, 180, 90, 45, 40, 75, 130, 140, 150, 160];
    this.randomBigRads = [227, 240, 300, 248, 200, 187, 210, 195, 320, 305, 310];
  }

  SpirographNode.prototype.randomise = function() {
    var r1, r2, s1, s2;
    s1 = this.randomSpeeds[Math.floor(Math.random() * this.randomSpeeds.length)];
    s2 = this.randomSpeeds[Math.floor(Math.random() * this.randomSpeeds.length)];
    r1 = this.randomSmallRads[Math.floor(Math.random() * this.randomSmallRads.length)];
    r2 = this.randomBigRads[Math.floor(Math.random() * this.randomBigRads.length)];
    TweenMax.to(this, 1.5, {
      radMin: r1,
      radMax: r2,
      speed: s1,
      radSpeed: s2,
      colorSpeed: Math.random()
    });
    return null;
  };

  SpirographNode.prototype.update = function() {
    var radius, x, y;
    this.radSin += this.radSpeed;
    this.radSin %= 360;
    radius = this.radMin + (Math.sin(MathUtils.degToRad(this.radSin)) * (this.radMax - this.radMin));
    this.sin += this.speed;
    this.sin %= 360;
    x = -Math.sin(MathUtils.degToRad(this.sin)) * radius;
    y = Math.cos(MathUtils.degToRad(this.sin)) * radius;
    this.moveTo(x + this.midX, y + this.midY, 0);
    this.color += this.colorSpeed;
    this.color %= 360;
    this.drawTrails();
    return null;
  };

  SpirographNode.prototype.updateTint = function() {
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    return null;
  };

  SpirographNode.prototype.drawTrails = function() {
    var i, inc, ptA, ptB, tInc, _i, _ref;
    this.graphics.clear();
    inc = 1 / this.recordedPositions;
    tInc = this.tailWidth / this.recordedPositions;
    ptA = this.positions[0];
    ptB = null;
    for (i = _i = 0, _ref = this.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = this.positions[i];
      ptB = this.positions[i + 1];
      this.hsb = [this.color, 100, 100];
      this.hex = ColourConversion.hsbToHex(this.hsb);
      this.graphics.lineStyle(i * tInc, this.hex, i * inc);
      this.graphics.moveTo(ptA.x, ptA.y);
      this.graphics.lineTo(ptB.x, ptB.y);
    }
    return null;
  };

  return SpirographNode;

})(Node);

SquidNode = (function(_super) {
  __extends(SquidNode, _super);

  function SquidNode(x_, y_, z_) {
    var i, n, _i;
    if (x_ == null) {
      x_ = 0;
    }
    if (y_ == null) {
      y_ = 0;
    }
    if (z_ == null) {
      z_ = 0;
    }
    this.drawNodePath = __bind(this.drawNodePath, this);
    this.update = __bind(this.update, this);
    this.setTailColor = __bind(this.setTailColor, this);
    this.setColor = __bind(this.setColor, this);
    SquidNode.__super__.constructor.call(this, 0, 0, z_);
    this.basePosition = {
      x: x_,
      y: y_
    };
    this.color = 0;
    this.tailColor = 0;
    this.view = new PIXI.DisplayObjectContainer();
    this.graphics = new PIXI.Graphics();
    this.view.addChild(this.graphics);
    this.head = new PIXI.Sprite(window.app.textures[0]);
    this.head.pivot.x = this.head.pivot.y = 16;
    this.view.addChild(this.head);
    this.setColor(this.color);
    this.tailWidth = 3;
    this.tailSpread = 40;
    this.recordedPositions = 120;
    this.positions = [];
    this.firstUpdate = true;
    this.nodes = [];
    for (i = _i = 0; _i < 5; i = ++_i) {
      n = new Node();
      n.recordedPositions = this.recordedPositions;
      n.fillPositions();
      n.sin = Math.random() * 360;
      n.inc = 2 + (3 * Math.random());
      this.nodes.push(n);
    }
    /*
    		make it spin
    		around it's position
    */

    this.sin = 0;
    this.speed = 1;
    this.radSin = 0;
    this.radSpeed = 5;
    this.radMin = 200;
    this.radMax = 240;
  }

  SquidNode.prototype.setColor = function(value) {
    this.color = value;
    this.hsb = [this.color, 100, 100];
    this.hex = ColourConversion.hsbToHex(this.hsb);
    this.head.tint = this.hex;
    return null;
  };

  SquidNode.prototype.setTailColor = function(value) {
    this.tailColor = value;
    return null;
  };

  SquidNode.prototype.update = function() {
    var alphaInc, ang, i, node, nx, ny, pcos, psin, ptA, ptB, radius, widthInc, x, xdif, y, ydif, _i, _j, _len, _ref, _ref1;
    this.sin += this.speed;
    this.sin %= 360;
    this.radSin += this.radSpeed;
    this.radSin %= 360;
    psin = Math.sin(MathUtils.degToRad(this.sin));
    pcos = Math.cos(MathUtils.degToRad(this.sin));
    radius = this.radMin + (Math.sin(MathUtils.degToRad(this.radSin)) * (this.radMax - this.radMin));
    x = -psin * radius;
    y = pcos * radius;
    this.moveTo(this.basePosition.x + x, this.basePosition.y + y);
    if (this.firstUpdate) {
      this.fillPositions();
      this.firstUpdate = false;
    }
    this.head.position.x = this.position.x;
    this.head.position.y = this.position.y;
    alphaInc = 1 / this.recordedPositions;
    widthInc = this.tailWidth / this.recordedPositions;
    this.graphics.clear();
    for (i = _i = 0, _ref = this.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = this.positions[i];
      ptB = this.positions[i + 1];
      this.graphics.lineStyle(i * widthInc, this.hex, i * alphaInc);
      this.graphics.moveTo(ptA.x, ptA.y);
      this.graphics.lineTo(ptB.x, ptB.y);
    }
    _ref1 = this.nodes;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      node = _ref1[_j];
      node.sin += node.inc;
      node.sin %= 360;
      x = 0;
      y = Math.sin(MathUtils.degToRad(node.sin)) * this.tailSpread;
      xdif = this.positions[this.recordedPositions - 2].x - this.positions[this.recordedPositions - 1].x;
      ydif = this.positions[this.recordedPositions - 2].y - this.positions[this.recordedPositions - 1].y;
      ang = Math.atan2(ydif, xdif);
      nx = -Math.sin(ang) * y;
      ny = Math.cos(ang) * y;
      node.moveTo(nx, ny);
      this.drawNodePath(node);
    }
    return null;
  };

  SquidNode.prototype.drawNodePath = function(node) {
    var alphaInc, i, oA, oB, ptA, ptB, scale, widthInc, _i, _ref;
    alphaInc = 1 / this.recordedPositions;
    widthInc = this.tailWidth / this.recordedPositions;
    scale = 1;
    for (i = _i = 0, _ref = node.positions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ptA = node.positions[i];
      ptB = node.positions[i + 1];
      oA = this.positions[i];
      oB = this.positions[i + 1];
      scale = 1 - (i / this.recordedPositions);
      this.graphics.lineStyle(i * widthInc, this.hex, i * alphaInc);
      this.graphics.moveTo(oA.x + (ptA.x * scale), oA.y + (ptA.y * scale));
      this.graphics.lineTo(oB.x + (ptB.x * scale), oB.y + (ptB.y * scale));
    }
    return null;
  };

  return SquidNode;

})(Node);

Smoky = (function(_super) {
  __extends(Smoky, _super);

  Smoky.id = 'Smoky';

  Smoky.prototype.numNodes = 200;

  Smoky.prototype.checkDist = 100;

  Smoky.prototype.checkDistSq = 0;

  Smoky.prototype.nodes = [];

  Smoky.prototype.sprites = [];

  function Smoky(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.mouseMove = __bind(this.mouseMove, this);
    this.update = __bind(this.update, this);
    this.resize = __bind(this.resize, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.checkDistSq = this.checkDist * this.checkDist;
    Smoky.__super__.constructor.call(this, this.renderer, this.name);
  }

  Smoky.prototype.load = function() {
    if (this.loaded) {
      this.windowWidth = window.innerWidth;
      this.windowHeight = window.innerHeight;
      this.areaWidth = this.windowWidth + 400;
      this.areaHeight = this.windowHeight + 400;
      Smoky.__super__.load.call(this);
      return;
    }
    this.windowWidth = window.innerWidth;
    this.windowHeight = window.innerHeight;
    this.areaWidth = this.windowWidth + 400;
    this.areaHeight = this.windowHeight + 400;
    this.createNodes();
    this.createSprites();
    return Smoky.__super__.load.call(this);
  };

  Smoky.prototype.unload = function() {
    Smoky.__super__.unload.call(this);
    return null;
  };

  Smoky.prototype.resize = function() {
    return null;
  };

  Smoky.prototype.createNodes = function() {
    var i, n, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      n = new Node(Math.random() * this.windowWidth, Math.random() * this.windowHeight);
      n.velocity.x = 3 - (6 * Math.random());
      n.velocity.y = 3 - (6 * Math.random());
      n.sinPos = Math.random() * 360;
      n.sinIncrement = Math.random() * 0.5;
      n.scaleAmount = Math.random() * 2;
      this.nodes.push(n);
    }
    return null;
  };

  Smoky.prototype.createSprites = function() {
    var i, sp, _i, _ref;
    this.tex = window.app.textures[0];
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(this.tex);
      sp.pivot.x = 16;
      sp.pivot.y = 16;
      sp.blendMode = PIXI.blendModes.SCREEN;
      sp.alpha = 0.1 + (Math.random() * 0.2);
      this.sprites.push(sp);
      this.view.addChild(sp);
    }
    return null;
  };

  Smoky.prototype.updateSprites = function() {
    var distTo, i, node, sp, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      node = this.nodes[i];
      node.position.x += node.velocity.x;
      node.position.y += node.velocity.y;
      node.sinPos += node.sinIncrement;
      node.sinPos %= 360;
      node.scale = 10 + (Math.sin(node.sinPos * (Math.PI / 180)) * node.scaleAmount);
      if (node.position.x > this.windowWidth + 200) {
        node.position.x -= this.areaWidth;
      } else if (node.position.x < -200) {
        node.position.x += this.areaWidth;
      }
      if (node.position.y > this.windowHeight + 200) {
        node.position.y -= this.areaHeight;
      } else if (node.position.y < -200) {
        node.position.y += this.areaHeight;
      }
      distTo = this.distanceTo({
        x: node.position.x,
        y: node.position.y
      }, {
        x: this.curX,
        y: this.curY
      });
      if (distTo.dist < this.checkDistSq) {
        node.velocity.x = ((distTo.xDif * -1) / this.checkDist) * 5;
        node.velocity.y = ((distTo.yDif * -1) / this.checkDist) * 5;
      }
      sp = this.sprites[i];
      sp.position.x = node.position.x;
      sp.position.y = node.position.y;
      sp.scale.x = sp.scale.y = node.scale;
    }
    return null;
  };

  Smoky.prototype.distanceTo = function(object, target) {
    var xDif, yDif;
    xDif = target.x - object.x;
    yDif = target.y - object.y;
    return {
      xDif: xDif,
      yDif: yDif,
      dist: (xDif * xDif) + (yDif * yDif)
    };
  };

  Smoky.prototype.update = function() {
    Smoky.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.curX = window.app.pointerPosition.x;
    this.curY = window.app.pointerPosition.y;
    this.updateSprites();
    return null;
  };

  Smoky.prototype.mouseMove = function(e) {
    this.curX = e.pageX;
    this.curY = e.pageY;
    return null;
  };

  return Smoky;

})(Sketch);

Spirals = (function(_super) {
  __extends(Spirals, _super);

  Spirals.id = 'Spirals';

  Spirals.prototype.midPoint = null;

  Spirals.prototype.nodes = [];

  Spirals.prototype.deadNodes = [];

  Spirals.prototype.newNodeCount = 1;

  Spirals.prototype.newNodeLimit = 10;

  Spirals.prototype.changeCount = 720;

  Spirals.prototype.changeLimit = 720;

  Spirals.prototype.rotateSpeed = 11;

  Spirals.prototype.moveSpeed = 0.6;

  Spirals.prototype.sqDist = 100;

  function Spirals(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.createSprite = __bind(this.createSprite, this);
    this.createNode = __bind(this.createNode, this);
    this.distToMidpoint = __bind(this.distToMidpoint, this);
    this.updateNodes = __bind(this.updateNodes, this);
    this.randomisePattern = __bind(this.randomisePattern, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Spirals.__super__.constructor.call(this, this.renderer, this.name);
  }

  Spirals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.gui.add(this, 'rotateSpeed', -50, 50).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.add(this, 'moveSpeed', 0.1, 10).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.close();
    }
    this.midPoint = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5
    };
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    this.randomisePattern();
    Spirals.__super__.load.call(this);
    return null;
  };

  Spirals.prototype.unload = function() {
    Spirals.__super__.unload.call(this);
    return null;
  };

  Spirals.prototype.update = function() {
    var newNode;
    Spirals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.spacePressed) {
      this.changeCount = this.changeLimit;
      window.app.spacePressed = false;
      this.randomisePattern();
    }
    this.newNodeCount--;
    if (this.newNodeCount === 0) {
      this.newNodeCount = this.newNodeLimit;
      newNode = this.createNode();
      this.nodes.push(newNode);
      this.view.addChild(newNode.sprite);
    }
    this.changeCount--;
    if (this.changeCount === 0) {
      this.randomisePattern();
      this.changeCount = this.changeLimit;
    }
    this.updateNodes();
    return null;
  };

  Spirals.prototype.resize = function() {
    if (this.midPoint !== null) {
      this.midPoint.x = window.innerWidth * 0.5;
      this.midPoint.y = window.innerHeight * 0.5;
    }
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    return null;
  };

  Spirals.prototype.randomisePattern = function() {
    TweenMax.to(this, 0.5, {
      rotateSpeed: -50 + (Math.random() * 100),
      ease: Power4.easeOut
    });
    TweenMax.to(this, 0.5, {
      moveSpeed: Math.random() * 3,
      ease: Power4.easeOut
    });
    return null;
  };

  Spirals.prototype.updateNodes = function() {
    var angle, i, newx, newy, node, _i, _ref;
    for (i = _i = _ref = this.nodes.length - 1; _i >= 0; i = _i += -1) {
      node = this.nodes[i];
      node.y += this.moveSpeed;
      angle = MathUtils.degToRad(node.phase);
      newx = -node.y * Math.sin(angle);
      newy = node.y * Math.cos(angle);
      node.sprite.position.x = this.midPoint.x + newx;
      node.sprite.position.y = this.midPoint.y + newy;
      node.phase += this.rotateSpeed;
      node.phase %= 360;
      node.sprite.scale.x = node.sprite.scale.y = 0.25 + ((this.distToMidpoint(node) / this.sqDist) * 4);
      if ((newx - (16 * 5) + this.midPoint.x) > window.innerWidth) {
        this.view.removeChild(node.sprite);
        this.nodes.splice(i, 1);
        this.deadNodes.push(node);
      }
    }
    return null;
  };

  Spirals.prototype.distToMidpoint = function(node) {
    var xDif, yDif;
    xDif = this.midPoint.x - node.sprite.position.x;
    yDif = this.midPoint.y - node.sprite.position.y;
    return (xDif * xDif) + (yDif * yDif);
  };

  Spirals.prototype.createNode = function() {
    var node;
    if (this.deadNodes.length === 0) {
      node = {
        y: 0,
        x: 0,
        sprite: this.createSprite(),
        phase: 0
      };
    } else {
      node = this.deadNodes[0];
      this.deadNodes.splice(0, 1);
      node.y = 0;
      node.x = 0;
      node.phase = 0;
    }
    return node;
  };

  Spirals.prototype.createSprite = function() {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = 16;
    sp.pivot.y = 16;
    return sp;
  };

  return Spirals;

})(Sketch);

Spirograph = (function(_super) {
  __extends(Spirograph, _super);

  function Spirograph(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.addNode = __bind(this.addNode, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Spirograph.__super__.constructor.call(this, this.renderer, this.name);
  }

  Spirograph.prototype.load = function() {
    if (!this.loaded) {
      this.makeGui();
      this.nodes = [];
      this.addNode();
      this.addNode();
      this.addNode();
    }
    Spirograph.__super__.load.call(this);
    return null;
  };

  Spirograph.prototype.unload = function() {
    Spirograph.__super__.unload.call(this);
    return null;
  };

  Spirograph.prototype.update = function() {
    var node, _i, _len, _ref;
    Spirograph.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.update();
    }
    return null;
  };

  Spirograph.prototype.resize = function() {
    return null;
  };

  Spirograph.prototype.addNode = function() {
    var folder, node;
    node = new SpirographNode();
    this.nodes.push(node);
    node.color = Math.random() * 360;
    node.updateTint();
    this.view.addChild(node.view);
    if (this.nodes.length === 1) {
      node.speed = 59.9;
      node.radSpeed = 122;
    } else if (this.nodes.length === 2) {
      node.speed = 60;
      node.radSpeed = 61;
    } else if (this.nodes.length === 3) {
      node.speed = 60;
      node.radSpeed = 119;
    }
    node.colorSpeed = Math.random();
    folder = this.gui.addFolder('Spirograph ' + this.nodes.length);
    folder.add(node, 'speed', 0.1, 359.9).listen();
    folder.add(node, 'radSpeed', 0.1, 359.9).listen();
    folder.add(node, 'radMin', 0.1, 500).listen();
    folder.add(node, 'radMax', 0.1, 500).listen();
    folder.add(node, 'tailWidth', 1, 30);
    folder.add(node, 'color', 0, 360.0);
    folder.add(node, 'colorSpeed', 0, 1).listen();
    folder.add(node, 'recordedPositions', 1, 360);
    folder.add(node, 'randomise');
    return null;
  };

  return Spirograph;

})(Sketch);

Squids = (function(_super) {
  __extends(Squids, _super);

  function Squids(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.random2 = __bind(this.random2, this);
    this.random1 = __bind(this.random1, this);
    this.random0 = __bind(this.random0, this);
    this.load = __bind(this.load, this);
    Squids.__super__.constructor.call(this, this.renderer, this.name);
  }

  Squids.prototype.load = function() {
    var col, i, squid, _i;
    if (!this.loaded) {
      this.makeGui();
      this.squids = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        squid = new SquidNode(window.innerWidth * ((1 / 4) * (i + 1)), window.innerHeight * 0.5);
        squid.speed = 1 + (Math.random() * 5);
        squid.radSpeed = 1 + (Math.random() * 36);
        col = Math.random() * 360;
        squid.setColor(col);
        squid.setTailColor(col);
        this.view.addChild(squid.view);
        this.squids.push(squid);
      }
      this.gui.add(this, 'random0');
      this.gui.add(this, 'random1');
      this.gui.add(this, 'random2');
    }
    Squids.__super__.load.call(this);
    return null;
  };

  Squids.prototype.random0 = function() {
    var col, squid;
    squid = this.squids[0];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.random1 = function() {
    var col, squid;
    squid = this.squids[1];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.random2 = function() {
    var col, squid;
    squid = this.squids[2];
    squid.speed = 1 + (Math.random() * 5);
    squid.radSpeed = 1 + (Math.random() * 36);
    col = Math.random() * 360;
    squid.setColor(col);
    squid.setTailColor(col);
    return null;
  };

  Squids.prototype.unload = function() {
    Squids.__super__.unload.call(this);
    return null;
  };

  Squids.prototype.update = function() {
    var squid, _i, _len, _ref;
    Squids.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    _ref = this.squids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      squid = _ref[_i];
      squid.update();
    }
    return null;
  };

  Squids.prototype.resize = function() {
    return null;
  };

  return Squids;

})(Sketch);

Stacks = (function(_super) {
  __extends(Stacks, _super);

  Stacks.prototype.yCount = 30;

  Stacks.prototype.xCount = 40;

  Stacks.prototype.minSpeed = -40;

  Stacks.prototype.maxSpeed = 40;

  Stacks.prototype.tgtScale = 1;

  Stacks.prototype.nodes = [];

  Stacks.prototype.deadNodes = [];

  function Stacks(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.randomiseSpeeds = __bind(this.randomiseSpeeds, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Stacks.__super__.constructor.call(this, this.renderer, this.name);
  }

  Stacks.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.makeGui();
      this.createSprites();
      this.gui.add(this, 'minSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
      this.gui.add(this, 'maxSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
    }
    Stacks.__super__.load.call(this);
    return null;
  };

  Stacks.prototype.unload = function() {
    Stacks.__super__.unload.call(this);
    return null;
  };

  Stacks.prototype.update = function() {
    Stacks.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.updateNodes();
    return null;
  };

  Stacks.prototype.resize = function() {
    return null;
  };

  Stacks.prototype.updateNodes = function() {
    var i, j, newSpeed, node, totSpeed, winWidth, xdif, _i, _j, _ref, _ref1;
    winWidth = window.innerWidth;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        node = this.nodes[i][j];
        node.sprite.position.x += node.speed;
        if (node.sprite.position.x <= 0) {
          node.sprite.position.x = 0.1;
          node.speed *= -1;
        } else if (node.sprite.position.x >= winWidth) {
          node.sprite.position.x = winWidth - 0.1;
          node.speed *= -1;
        }
        if (this.nodes[i + 1]) {
          if (node.sprite.position.x >= this.nodes[i + 1][j].sprite.position.x - (16 * this.tgtScale)) {
            xdif = Math.abs(node.sprite.position.x - this.nodes[i + 1][j].sprite.position.x) - (16.2 * this.tgtScale);
            if (xdif < 0) {
              xdif *= -1;
            }
            newSpeed = this.nodes[i + 1][j].speed;
            totSpeed = newSpeed + node.speed;
            this.nodes[i + 1][j].speed = node.speed;
            node.speed = newSpeed;
            node.sprite.position.x -= xdif * 0.5;
            this.nodes[i + 1][j].sprite.position.x += xdif * 0.5;
            /*
            						ms 4
            						os 2
            						os / (ms + os)
            						2 / (4 + 2)
            */

          }
        }
      }
    }
    return null;
  };

  Stacks.prototype.createSprites = function() {
    var i, j, _i, _j, _ref, _ref1;
    this.tgtScale = (window.innerHeight / (this.yCount - 1)) / 30;
    this.nodes = [];
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.nodes[i] = [];
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j] = {
          sprite: this.addSprite(i, j),
          speed: 0
        };
      }
    }
    this.randomiseSpeeds();
    return null;
  };

  Stacks.prototype.addSprite = function(x, y) {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = sp.pivot.y = 16;
    sp.position.x = x * (window.innerWidth / this.xCount);
    sp.position.y = y * (30 * this.tgtScale);
    sp.scale.x = sp.scale.y = this.tgtScale;
    this.view.addChild(sp);
    return sp;
  };

  Stacks.prototype.randomiseSpeeds = function() {
    var i, j, speedDif, _i, _j, _ref, _ref1;
    speedDif = this.maxSpeed - this.minSpeed;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j].speed = this.minSpeed + (Math.random() * speedDif);
      }
    }
    return null;
  };

  return Stacks;

})(Sketch);

TessellationOne = (function(_super) {
  __extends(TessellationOne, _super);

  function TessellationOne(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    TessellationOne.__super__.constructor.call(this, this.renderer, this.name);
  }

  TessellationOne.prototype.load = function() {
    var g, sp;
    if (!this.loaded) {
      this.makeGui();
      this.unitSize = 10;
      this.tiles = {};
      this.tileLayers = [];
      this.curLayer = 0;
      g = new PIXI.Graphics();
      this.drawTile(g);
      this.tileTex = g.generateTexture();
      this.spriteHolder = new PIXI.DisplayObjectContainer();
      this.spriteHolder.position.x = window.innerWidth * 0.5;
      this.spriteHolder.position.y = window.innerHeight * 0.5;
      this.view.addChild(this.spriteHolder);
    }
    while (this.spriteHolder.children.length > 0) {
      this.spriteHolder.removeChild(this.spriteHolder.children[0]);
    }
    this.tiles = {};
    this.tileLayers = [];
    this.curLayer = 0;
    sp = new PIXI.Sprite(this.tileTex);
    sp.anchor.x = sp.anchor.y = 0.5;
    this.spriteHolder.addChild(sp);
    this.tileLayers.push([sp]);
    this.tiles['0_0'] = sp;
    TessellationOne.__super__.load.call(this);
    return null;
  };

  TessellationOne.prototype.drawTile = function(canvas) {
    canvas.beginFill(0xFFFFFF);
    this.drawVert(canvas, -1, -3);
    canvas.endFill();
    canvas.beginFill(0xFFFFFF);
    this.drawVert(canvas, -2, 0);
    canvas.endFill();
    canvas.beginFill(0x777777);
    this.drawHori(canvas, -3, -2);
    canvas.endFill();
    canvas.beginFill(0x777777);
    this.drawHori(canvas, 0, -1);
    canvas.endFill();
    return null;
  };

  TessellationOne.prototype.drawVert = function(canvas, xOff, yOff) {
    canvas.moveTo(xOff * this.unitSize, yOff * this.unitSize);
    canvas.lineTo((xOff + 2) * this.unitSize, yOff * this.unitSize);
    canvas.lineTo((xOff + 2) * this.unitSize, (yOff + 2) * this.unitSize);
    canvas.lineTo((xOff + 3) * this.unitSize, (yOff + 2) * this.unitSize);
    canvas.lineTo((xOff + 3) * this.unitSize, (yOff + 3) * this.unitSize);
    canvas.lineTo((xOff + 1) * this.unitSize, (yOff + 3) * this.unitSize);
    canvas.lineTo((xOff + 1) * this.unitSize, (yOff + 1) * this.unitSize);
    canvas.lineTo(xOff * this.unitSize, (yOff + 1) * this.unitSize);
    canvas.lineTo(xOff * this.unitSize, yOff * this.unitSize);
    return null;
  };

  TessellationOne.prototype.drawHori = function(canvas, xOff, yOff) {
    canvas.moveTo(xOff * this.unitSize, (yOff + 1) * this.unitSize);
    canvas.lineTo((xOff + 2) * this.unitSize, (yOff + 1) * this.unitSize);
    canvas.lineTo((xOff + 2) * this.unitSize, yOff * this.unitSize);
    canvas.lineTo((xOff + 3) * this.unitSize, yOff * this.unitSize);
    canvas.lineTo((xOff + 3) * this.unitSize, (yOff + 2) * this.unitSize);
    canvas.lineTo((xOff + 1) * this.unitSize, (yOff + 2) * this.unitSize);
    canvas.lineTo((xOff + 1) * this.unitSize, (yOff + 3) * this.unitSize);
    canvas.lineTo(xOff * this.unitSize, (yOff + 3) * this.unitSize);
    canvas.lineTo(xOff * this.unitSize, (yOff + 1) * this.unitSize);
    return null;
  };

  TessellationOne.prototype.addLayer = function() {
    var a, b, c, d, layer, tile, x, y, _i, _len, _ref;
    layer = [];
    _ref = this.tileLayers[this.curLayer];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      x = tile.position.x / this.unitSize;
      y = tile.position.y / this.unitSize;
      a = (x + 2) + '_' + (y + 4);
      b = (x - 4) + '_' + (y + 2);
      c = (x - 2) + '_' + (y - 4);
      d = (x + 4) + '_' + (y - 2);
      if (this.tiles[a] === void 0) {
        this.tiles[a] = this.addTile(x + 2, y + 4);
        layer.push(this.tiles[a]);
      }
      if (this.tiles[b] === void 0) {
        this.tiles[b] = this.addTile(x - 4, y + 2);
        layer.push(this.tiles[b]);
      }
      if (this.tiles[c] === void 0) {
        this.tiles[c] = this.addTile(x - 2, y - 4);
        layer.push(this.tiles[c]);
      }
      if (this.tiles[d] === void 0) {
        this.tiles[d] = this.addTile(x + 4, y - 2);
        layer.push(this.tiles[d]);
      }
    }
    this.tileLayers.push(layer);
    this.curLayer++;
    return null;
  };

  TessellationOne.prototype.addTile = function(x, y) {
    var sp;
    sp = new PIXI.Sprite(this.tileTex);
    sp.anchor.x = sp.anchor.y = 0.5;
    sp.position.x = x * this.unitSize;
    sp.position.y = y * this.unitSize;
    sp.alpha = 1 - (this.curLayer / 20);
    this.spriteHolder.addChild(sp);
    return sp;
  };

  TessellationOne.prototype.unload = function() {
    TessellationOne.__super__.unload.call(this);
    return null;
  };

  TessellationOne.prototype.update = function() {
    TessellationOne.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (this.curLayer < 20) {
      this.addLayer();
    }
    return null;
  };

  TessellationOne.prototype.resize = function() {
    return null;
  };

  return TessellationOne;

})(Sketch);

Trails = (function(_super) {
  __extends(Trails, _super);

  Trails.id = 'Trails';

  Trails.prototype.trailLength = 70;

  Trails.prototype.sprites = [];

  Trails.prototype.positions = [];

  Trails.prototype.sinOffset = 0;

  Trails.prototype.sinIncrement = 0;

  Trails.prototype.maxScale = 4;

  Trails.prototype.minScale = 1;

  Trails.prototype.wobbleAngle = 17;

  function Trails(renderer, name) {
    this.renderer = renderer;
    this.name = name;
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Trails.__super__.constructor.call(this, this.renderer, this.name);
    this.toAdd = 0.00000000001;
    this.sinIncrement = MathUtils.twoPI / 18;
  }

  Trails.prototype.load = function() {
    var i, sp, _i, _ref,
      _this = this;
    if (this.loaded) {
      this.gui.domElement.style.display = 'block';
      this.gui.close();
      Trails.__super__.load.call(this);
    } else {
      this.curX = this.mouseX = window.innerWidth * 0.5;
      this.curY = this.mouseY = window.innerHeight * 0.5;
      for (i = _i = 0, _ref = this.trailLength - 1; _i <= _ref; i = _i += 1) {
        sp = new PIXI.Sprite(window.app.textures[0]);
        sp.alpha = 0;
        sp.pivot.x = 16;
        sp.pivot.y = 16;
        this.view.addChild(sp);
        this.sprites.push(sp);
      }
      this.makeGui();
      this.gui.add(this, 'sinIncrement', 0, MathUtils.twoPI / 5);
      this.gui.add(this, 'wobbleAngle', 0, 90);
      this.gui.add(this, 'maxScale', 0, 10).listen().onChange(function() {
        if (_this.maxScale < _this.minScale) {
          return _this.minScale = _this.maxScale;
        }
      });
      this.gui.add(this, 'minScale', 0, 10).listen().onChange(function() {
        if (_this.minScale > _this.maxScale) {
          return _this.maxScale = _this.minScale;
        }
      });
      this.gui.close();
      Trails.__super__.load.call(this);
    }
    return null;
  };

  Trails.prototype.unload = function() {
    Trails.__super__.unload.call(this);
    return null;
  };

  Trails.prototype.update = function() {
    var angle, dist, newX, newY, p, pos, vecX, vecY, _i, _len, _ref;
    Trails.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    angle = MathUtils.degToRad(Math.sin(this.sinOffset) * this.wobbleAngle);
    vecX = window.app.pointerPosition.x - this.curX;
    vecY = window.app.pointerPosition.y - this.curY;
    newX = (vecX * Math.cos(angle)) - (vecY * Math.sin(angle));
    newY = (vecX * Math.sin(angle)) + (vecY * Math.cos(angle));
    this.curX += newX / 100;
    this.curY += newY / 100;
    this.positions.push({
      x: this.curX,
      y: this.curY
    });
    if (this.positions.length > this.trailLength) {
      this.positions.splice(0, 1);
    }
    _ref = this.positions;
    for (p = _i = 0, _len = _ref.length; _i < _len; p = ++_i) {
      pos = _ref[p];
      this.sprites[p].scale.x = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].scale.y = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].position.x = pos.x;
      this.sprites[p].position.y = pos.y;
      this.sprites[p].alpha = p / this.trailLength;
    }
    dist = Math.sqrt((vecX * vecX) + (vecY * vecY));
    if (dist === 0) {
      dist = 1;
    }
    this.toAdd = MathUtils.degToRad(30 / dist);
    this.sinOffset += this.sinIncrement + this.toAdd;
    this.sinOffset %= MathUtils.twoPI;
    return null;
  };

  return Trails;

})(Sketch);

Menu = (function() {
  function Menu(app, data, renderer) {
    var dist, xd, yd;
    this.app = app;
    this.data = data;
    this.renderer = renderer;
    this.checkAngleDistance = __bind(this.checkAngleDistance, this);
    this.updateButtonTint = __bind(this.updateButtonTint, this);
    this.updateMenuText = __bind(this.updateMenuText, this);
    this.update = __bind(this.update, this);
    this.disable = __bind(this.disable, this);
    this.enable = __bind(this.enable, this);
    this.resize = __bind(this.resize, this);
    this.hide = __bind(this.hide, this);
    this.show = __bind(this.show, this);
    this.view = new PIXI.DisplayObjectContainer();
    this.bgAlpha = 0.9;
    this.bg = new PIXI.Graphics();
    this.view.addChild(this.bg);
    this.resize();
    this.isOpen = true;
    this.buttons = [];
    this.buttonSprites = [];
    this.buttonSize = 20;
    this.radius = (Math.min(window.innerWidth, window.innerHeight) * 0.5) - 50;
    this.createButtons();
    xd = this.buttons[1].position.x - this.buttons[0].position.x;
    yd = this.buttons[1].position.y - this.buttons[0].position.y;
    dist = Math.sqrt((xd * xd) + (yd * yd));
    this.overScale = (dist * 0.5) / this.buttonSize;
    this.currentButton = this.buttons[this.app.currentSketch];
    this.menuText = new PIXI.Text(this.currentButton.name, {
      font: '300 27px Lato',
      fill: '#e3e3e3'
    });
    this.menuText.anchor.x = 0.5;
    this.menuText.anchor.y = 0.5;
    this.menuText.position.x = Math.round(window.innerWidth * 0.5);
    this.menuText.position.y = Math.round(window.innerHeight * 0.5);
    this.view.addChild(this.menuText);
  }

  Menu.prototype.show = function() {
    TweenMax.killTweensOf(this.view.position);
    TweenMax.to(this.view.position, 0.3, {
      y: 0,
      ease: Power4.easeOut
    });
    this.isOpen = true;
    return null;
  };

  Menu.prototype.hide = function() {
    this.isOpen = false;
    TweenMax.killTweensOf(this.view.position);
    TweenMax.to(this.view.position, 0.3, {
      y: window.innerHeight,
      ease: Power4.easeOut
    });
    return null;
  };

  Menu.prototype.resize = function() {
    this.bg.clear();
    this.bg.beginFill(0, this.bgAlpha);
    this.bg.drawRect(0, 0, window.innerWidth, window.innerHeight);
    this.bg.endFill();
    return null;
  };

  Menu.prototype.enable = function() {
    return null;
  };

  Menu.prototype.disable = function() {
    return null;
  };

  Menu.prototype.update = function() {
    var but, curAngle, dist, i, minDist, xd, yd, _i, _j, _len, _ref, _ref1;
    if (this.view.position.y === window.innerHeight) {
      return;
    }
    yd = (window.innerHeight * 0.5) - this.app.pointerPosition.y;
    xd = (window.innerWidth * 0.5) - this.app.pointerPosition.x;
    curAngle = MathUtils.radToDeg(Math.atan2(yd, xd));
    curAngle += 180;
    minDist = 180;
    for (i = _i = 0, _ref = this.buttons.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.buttonSprites[i].position.x = (window.innerWidth * 0.5) + this.buttons[i].position.x;
      this.buttonSprites[i].position.y = (window.innerHeight * 0.5) + this.buttons[i].position.y;
      dist = this.checkAngleDistance(curAngle, this.buttons[i].angle);
      if (dist < minDist) {
        minDist = dist;
        this.currentButton = this.buttons[i];
      }
    }
    _ref1 = this.buttons;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      but = _ref1[_j];
      if (but === this.currentButton && !but.active) {
        but.active = true;
        this.view.addChild(this.buttonSprites[but.id]);
        TweenMax.killTweensOf(this.buttonSprites[but.id].scale);
        TweenMax.killTweensOf(but);
        TweenMax.killTweensOf(this.menuText);
        TweenMax.to(this.buttonSprites[but.id].scale, 1.2, {
          x: this.overScale,
          y: this.overScale,
          ease: Elastic.easeOut
        });
        TweenMax.to(but, 0.3, {
          s: 100,
          onUpdate: this.updateButtonTint,
          onUpdateParams: [but],
          ease: Power4.easeOut
        });
        TweenMax.to(this.menuText, 0.15, {
          alpha: 0,
          ease: Power4.easeOut,
          onComplete: this.updateMenuText
        });
      } else if (but.active && but !== this.currentButton) {
        but.active = false;
        TweenMax.killTweensOf(this.buttonSprites[but.id].scale);
        TweenMax.killTweensOf(but);
        TweenMax.to(this.buttonSprites[but.id].scale, 1.2, {
          x: 1,
          y: 1,
          ease: Elastic.easeOut
        });
        TweenMax.to(but, 1.2, {
          s: 0,
          onUpdate: this.updateButtonTint,
          onUpdateParams: [but],
          ease: Power4.easeOut
        });
      }
    }
    return null;
  };

  Menu.prototype.updateMenuText = function() {
    this.menuText.setText(this.currentButton.name);
    TweenMax.to(this.menuText, 0.15, {
      alpha: 1,
      ease: Power4.easeOut
    });
    return null;
  };

  Menu.prototype.updateButtonTint = function(but) {
    this.buttonSprites[but.id].tint = ColourConversion.hsbToHex([but.angle, but.s, but.b]);
    return null;
  };

  Menu.prototype.checkAngleDistance = function(current, target) {
    var dif;
    dif = Math.abs(current - target);
    if (dif > 180) {
      dif = 360 - dif;
    }
    return dif;
  };

  Menu.prototype.createButtons = function() {
    var but, i, inc, x, y, _i, _ref;
    inc = 360 / this.data.length;
    for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      x = Math.cos(MathUtils.degToRad(inc * i)) * this.radius;
      y = Math.sin(MathUtils.degToRad(inc * i)) * this.radius;
      but = new Node(x, y);
      but.angle = inc * i;
      but.id = i;
      but.name = this.data[i].classId;
      but.active = false;
      but.s = 0;
      but.b = 100;
      this.buttons.push(but);
      this.createButtonSprite(x, y);
    }
    return null;
  };

  Menu.prototype.createButtonSprite = function(x, y) {
    var sp;
    sp = new PIXI.Graphics();
    sp.beginFill(0xe3e3e3);
    sp.drawCircle(0, 0, this.buttonSize);
    sp.endFill();
    sp.position.x = x;
    sp.position.y = y;
    this.buttonSprites.push(sp);
    this.view.addChild(sp);
    return null;
  };

  return Menu;

})();

PWPData = (function() {
  function PWPData() {}

  PWPData.prototype.data = [
    {
      className: Smoky,
      classId: "Smoky",
      description: "Everyone starts with particles, right? Anyway, I was mucking around with them and liked the sort of smoky, foggy look the sprite had when it was really big.",
      instructions: "Just wiggle your mouse about to disturb the smoke a little."
    }, {
      className: Trails,
      classId: "Trails",
      description: "Mouse trails are pretty ubiquitous too. This one looked more alive when I was wiggling my mouse, so I've added a heading vector that fluctuates across an angle spread. Smaller sizes work better on smaller screens.",
      instructions: "A simple mouse trail."
    }, {
      className: Dots,
      classId: "Dots",
      description: "I've always loved LED grids, chuck in some rhythmic patterns and they hypnotise me. I might come back to this and write an image/text parser for it.",
      instructions: "Lots of settings for this one\nHave a play"
    }, {
      className: Spirals,
      classId: "Spirals",
      description: "Nature is full of Spirals and they're lovely to look at. This one moves between random selections which alters the patterns produced. The strobing effect makes it look more complicated than it is and becomes almost kaleidoscopic. I may have stared at this one for hours.",
      instructions: "It changes automagically, but hitting space will force a new random selection"
    }, {
      className: SineWave,
      classId: "Sine Wave",
      description: "A lot of the previous experiments used sine values of some sort and they look pretty cool too. This one started out as a plain old sine wave, but I chucked in some rotation after staring at spirals and it makes some equally pleasing patterns when it strobes.",
      instructions: "Play with the settings in this one"
    }, {
      className: Stacks,
      classId: "Stacks",
      description: "It's sort of like an abacus.",
      instructions: "Just watch it"
    }, {
      className: Fractals,
      classId: "Fractals",
      description: "....",
      instructions: "...."
    }, {
      className: Radar,
      classId: "Radar",
      description: "....",
      instructions: "...."
    }, {
      className: Ribbon,
      classId: "Ribbon",
      description: "....",
      instructions: "...."
    }, {
      className: Orbits,
      classId: "Orbits",
      description: "....",
      instructions: "...."
    }, {
      className: Comets,
      classId: "Comets",
      description: "....",
      instructions: "...."
    }, {
      className: PlanktonTank,
      classId: "PlanktonTank",
      description: "....",
      instructions: "...."
    }, {
      className: Spirograph,
      classId: "Spirograph",
      description: "....",
      instructions: "...."
    }, {
      className: Squids,
      classId: "Squids",
      description: "....",
      instructions: "...."
    }, {
      className: PictureTile,
      classId: "PictureTile",
      description: "....",
      instructions: "...."
    }, {
      className: ShapeShifter,
      classId: "ShapeShifter",
      description: "....",
      instructions: "...."
    }, {
      className: QuadTreeTest,
      classId: "QuadTreeTest",
      description: "....",
      instructions: "...."
    }, {
      className: TessellationOne,
      classId: "TessellationOne",
      description: "....",
      instructions: "...."
    }, {
      className: Penrose,
      classId: "Penrose",
      description: "....",
      instructions: "...."
    }
  ];

  return PWPData;

})();

App = (function() {
  function App() {
    this.update = __bind(this.update, this);
    this.removeGui = __bind(this.removeGui, this);
    this.selectSketch = __bind(this.selectSketch, this);
    this.prev = __bind(this.prev, this);
    this.next = __bind(this.next, this);
    this.handleKeyPress = __bind(this.handleKeyPress, this);
    this.handleMove = __bind(this.handleMove, this);
    this.handleEnd = __bind(this.handleEnd, this);
    this.handleStart = __bind(this.handleStart, this);
    var i, _i, _len, _ref,
      _this = this;
    this.data = new PWPData().data;
    this.spacePressed = false;
    this.infoOpen = true;
    this.renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight);
    this.stage = new PIXI.Stage(0x0a0a0a);
    document.body.appendChild(this.renderer.view);
    this.textures = [PIXI.Texture.fromImage('img/node.png')];
    this.sketches = [];
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      this.sketches.push({
        sketch: new i.className(this.renderer, i.classId),
        id: i.classId
      });
    }
    this.numSketches = this.sketches.length;
    this.currentSketch = this.sketches.length - 1;
    this.sketchHolder = new PIXI.DisplayObjectContainer();
    this.bg = new PIXI.Graphics();
    this.bg.beginFill(0x0a0a0a);
    this.bg.drawRect(0, 0, window.innerWidth, window.innerHeight);
    this.bg.endFill();
    this.sketchHolder.addChild(this.bg);
    this.menuPanel = new Menu(this, this.data);
    this.info = document.getElementById('wrapper');
    this.stage.addChild(this.sketchHolder);
    this.sketchHolder.addChild(this.menuPanel.view);
    this.buttonHolder = new PIXI.DisplayObjectContainer();
    this.buttonHolder.position.x = -64;
    this.buttonHolder.position.y = window.innerHeight;
    this.stage.addChild(this.buttonHolder);
    this.tab = PIXI.Sprite.fromImage('img/menu.png');
    this.tab.position.y = -64;
    this.buttonHolder.addChild(this.tab);
    this.tab.interactive = true;
    this.tab.buttonMode = true;
    this.infoTab = PIXI.Sprite.fromImage('img/info.png');
    this.infoTab.position.x = 65;
    this.buttonHolder.addChild(this.infoTab);
    this.infoTab.interactive = true;
    this.infoTab.buttonMode = true;
    this.pointerPosition = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5
    };
    this.mousePressed = false;
    this.enableObject(this.sketchHolder);
    this.sketchHolder.hitArea = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight);
    if (Modernizr.touch) {
      this.tab.tap = function() {
        if (_this.infoOpen) {
          return;
        }
        TweenMax.killTweensOf(_this.buttonHolder.position);
        TweenMax.to(_this.buttonHolder.position, 0.3, {
          x: -64,
          ease: Power4.easeOut,
          onComplete: _this.menuPanel.show
        });
        return null;
      };
      this.info.ontouchend = function() {
        _this.infoOpen = false;
        TweenMax.to(_this.info, 0.3, {
          css: {
            left: '-100%'
          },
          ease: Power4.easeOut
        });
        TweenMax.to(_this.infoTab.position, 0.3, {
          y: -64,
          ease: Power4.easeOut,
          delay: 0.3
        });
        return null;
      };
      this.infoTab.tap = function() {
        _this.infoOpen = true;
        TweenMax.to(_this.infoTab.position, 0.3, {
          y: 0,
          ease: Power4.easeOut
        });
        TweenMax.to(_this.info, 0.3, {
          css: {
            left: 0
          },
          ease: Power4.easeOut,
          delay: 0.3
        });
        return null;
      };
    } else {
      this.tab.mouseup = function() {
        if (_this.infoOpen) {
          return;
        }
        TweenMax.killTweensOf(_this.buttonHolder.position);
        TweenMax.to(_this.buttonHolder.position, 0.3, {
          x: -64,
          ease: Power4.easeOut,
          onComplete: _this.menuPanel.show
        });
        return null;
      };
      this.info.onclick = function() {
        _this.infoOpen = false;
        TweenMax.to(_this.info, 0.3, {
          css: {
            left: '-100%'
          },
          ease: Power4.easeOut
        });
        TweenMax.to(_this.infoTab.position, 0.3, {
          y: -64,
          ease: Power4.easeOut,
          delay: 0.3
        });
        return null;
      };
      this.infoTab.mouseup = function() {
        _this.infoOpen = true;
        TweenMax.to(_this.infoTab.position, 0.3, {
          y: 0,
          ease: Power4.easeOut
        });
        TweenMax.to(_this.info, 0.3, {
          css: {
            left: 0
          },
          ease: Power4.easeOut,
          delay: 0.3
        });
        return null;
      };
    }
    window.onresize = function() {
      var sketch, _j, _len1, _ref1;
      _this.menuPanel.resize();
      _this.buttonHolder.position.y = window.innerHeight;
      _this.renderer.resize(window.innerWidth, window.innerHeight);
      _this.bg.clear();
      _this.bg.beginFill(_this.stageColor);
      _this.bg.drawRect(0, 0, window.innerWidth, window.innerHeight);
      _this.bg.endFill();
      _this.sketchHolder.hitArea = new PIXI.Rectangle(0, 0, window.innerWidth, window.innerHeight);
      _ref1 = _this.sketches;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        sketch = _ref1[_j];
        sketch.sketch.resize();
      }
      return null;
    };
    window.onkeyup = this.handleKeyPress;
    requestAnimationFrame(this.update);
  }

  App.prototype.enableObject = function(target) {
    target.interactive = true;
    if (!Modernizr.touch) {
      target.mousemove = this.handleMove;
      target.mousedown = this.handleStart;
      target.mouseup = this.handleEnd;
      target.mouseupoutside = this.handleEnd;
    } else {
      target.touchstart = this.handleStart;
      target.touchend = this.handleEnd;
      target.touchmove = this.handleMove;
    }
    return null;
  };

  App.prototype.handleStart = function(e) {
    this.mousePressed = true;
    this.pointerPosition.x = e.global.x;
    this.pointerPosition.y = e.global.y;
    return null;
  };

  App.prototype.handleEnd = function() {
    this.mousePressed = false;
    if (this.menuPanel.isOpen && !this.infoOpen) {
      this.selectSketch(this.menuPanel.currentButton.id);
      this.menuPanel.hide();
      TweenMax.to(this.buttonHolder.position, 0.3, {
        x: 0,
        ease: Power4.easeOut,
        delay: 0.3
      });
    }
    return null;
  };

  App.prototype.handleMove = function(e) {
    this.pointerPosition.x = e.global.x;
    this.pointerPosition.y = e.global.y;
    return null;
  };

  App.prototype.handleKeyPress = function(e) {
    var unicode;
    e.preventDefault();
    unicode = e.keyCode ? e.keyCode : e.charCode;
    if (unicode === 37) {
      this.prev();
    } else if (unicode === 39) {
      this.next();
    } else if (unicode === 32) {
      this.spacePressed = true;
    }
    return null;
  };

  App.prototype.next = function() {
    var lastSketch;
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('next');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.prev = function() {
    var lastSketch;
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('prev');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.selectSketch = function(id) {
    var lastSketch;
    if (id === this.currentSketch) {
      return;
    }
    lastSketch = this.sketches[this.currentSketch];
    this.currentSketch = id;
    this.unloadSketch(lastSketch.sketch);
    return null;
  };

  App.prototype.unloadSketch = function(sketch) {
    if (sketch.gui !== null) {
      TweenMax.to(sketch.gui.domElement, 0.3, {
        css: {
          opacity: 0
        },
        ease: Power4.easeOut
      });
    }
    TweenMax.to(sketch.view, 1, {
      alpha: 0,
      ease: Power4.easeOut,
      onComplete: this.removeGui,
      onCompleteParams: [sketch]
    });
    return null;
  };

  App.prototype.removeGui = function(sketch) {
    sketch.unload();
    this.sketchHolder.removeChild(sketch.view);
    if (sketch.gui !== null) {
      document.body.removeChild(sketch.gui.domElement);
    }
    this.loadCurrentSketch();
    return null;
  };

  App.prototype.changeSketch = function(dir) {
    if (dir === 'next') {
      this.currentSketch++;
    } else if (dir === 'prev') {
      this.currentSketch--;
    }
    if (this.currentSketch === this.sketches.length) {
      this.currentSketch = 0;
    } else if (this.currentSketch < 0) {
      this.currentSketch = this.sketches.length - 1;
    }
    return null;
  };

  App.prototype.loadCurrentSketch = function() {
    this.sketches[this.currentSketch].sketch.load();
    this.sketches[this.currentSketch].sketch.view.alpha = 0;
    this.sketchHolder.addChildAt(this.sketches[this.currentSketch].sketch.view, 1);
    if (this.sketches[this.currentSketch].sketch.gui !== null) {
      this.sketches[this.currentSketch].sketch.gui.domElement.style.opacity = 0;
      document.body.appendChild(this.sketches[this.currentSketch].sketch.gui.domElement);
      TweenMax.to(this.sketches[this.currentSketch].sketch.gui.domElement, 0.3, {
        css: {
          opacity: 1
        },
        ease: Power4.easeOut,
        delay: 0.5
      });
    }
    TweenMax.to(this.sketches[this.currentSketch].sketch.view, 1, {
      alpha: 1,
      ease: Power4.easeOut
    });
    return null;
  };

  App.prototype.update = function() {
    this.menuPanel.update();
    if (this.sketches[this.currentSketch].sketch.loaded) {
      this.sketches[this.currentSketch].sketch.update();
    }
    this.renderer.render(this.stage);
    requestAnimationFrame(this.update);
    return null;
  };

  return App;

})();
