// Generated by CoffeeScript 1.6.3
var App, Dots, Fractals, InfoPanel, MathUtils, Menu, MenuButton, Node, Orbits, PWPData, Point, Radar, Ribbon, SineWave, Sketch, Smoky, Spirals, Stacks, Trails,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Sketch = (function() {
  Sketch.prototype.view = null;

  Sketch.prototype.cancelled = false;

  Sketch.prototype.loaded = false;

  Sketch.prototype.renderer = null;

  Sketch.prototype.stage = null;

  function Sketch(renderer) {
    this.renderer = renderer;
  }

  Sketch.prototype.load = function() {
    this.cancelled = false;
    if (!this.loaded) {
      requestAnimationFrame(this.update);
    }
    this.loaded = true;
    this.stage.visible = true;
    return null;
  };

  Sketch.prototype.unload = function() {
    this.cancelled = true;
    this.stage.visible = false;
    return null;
  };

  Sketch.prototype.update = function() {
    requestAnimationFrame(this.update);
    if (this.cancelled) {
      return;
    }
    return null;
  };

  Sketch.prototype.resize = function() {
    return null;
  };

  Sketch.prototype.makeGui = function() {
    var gui;
    gui = new dat.GUI({
      autoPlace: false
    });
    gui.domElement.style.zIndex = 100;
    gui.domElement.style.position = 'absolute';
    gui.domElement.style.top = 0;
    gui.domElement.style.left = 0;
    gui.domElement.style.height = 'auto';
    return gui;
  };

  return Sketch;

})();

Dots = (function(_super) {
  __extends(Dots, _super);

  Dots.id = 'Dots';

  Dots.prototype.dots = [];

  Dots.prototype.deadDots = [];

  Dots.prototype.xCounter = 0;

  Dots.prototype.xLimit = 0;

  Dots.prototype.xDir = 1;

  Dots.prototype.yCounter = 0;

  Dots.prototype.yLimit = 0;

  Dots.prototype.yDir = 1;

  Dots.prototype.curX = 0;

  Dots.prototype.curY = 0;

  Dots.prototype.mouseX = 0;

  Dots.prototype.mouseY = 0;

  Dots.prototype.easeX = 0;

  Dots.prototype.easeY = 0;

  Dots.prototype.spriteSize = 32;

  Dots.prototype.invert = true;

  Dots.prototype.mouseTrail = true;

  Dots.prototype.xFollow = false;

  Dots.prototype.xBounce = true;

  Dots.prototype.xLeft = false;

  Dots.prototype.xRight = false;

  Dots.prototype.xOff = false;

  Dots.prototype.lastX = 'follow';

  Dots.prototype.yFollow = false;

  Dots.prototype.yBounce = false;

  Dots.prototype.yUp = false;

  Dots.prototype.yDown = true;

  Dots.prototype.yOff = false;

  Dots.prototype.lastY = 'follow';

  function Dots(renderer) {
    this.renderer = renderer;
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.updateGui = __bind(this.updateGui, this);
    Dots.__super__.constructor.call(this, this.renderer);
  }

  Dots.prototype.updateGui = function() {
    var c, _i, _len, _ref;
    _ref = this.gui.__controllers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.updateDisplay();
    }
    return null;
  };

  Dots.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'spriteSize', 16, 128, 8).onFinishChange(function(val) {
        _this.spriteSize = val;
        return _this.resize();
      });
      this.gui.add(this, 'invert');
      this.gui.add(this, 'mouseTrail');
      this.gui.add(this, 'xFollow').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xFollow = true) {
          _this.xBounce = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'follow';
          _this.xBounce = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xBounce').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xBounce = true) {
          _this.xFollow = _this.xLeft = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'bounce';
          _this.xFollow = _this.xLeft = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xLeft').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xLeft = true) {
          _this.xDir = -1;
          _this.xFollow = _this.xBounce = _this.xRight = _this.xOff = false;
        } else {
          _this.lastX = 'left';
          _this.xFollow = _this.xBounce = _this.xRight = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xRight').onChange(function(val) {
        _this.xFollow = val;
        if (_this.xRight = true) {
          _this.xDir = 1;
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xOff = false;
        } else {
          _this.lastX = 'right';
          _this.xFollow = _this.xBounce = _this.xLeft = false;
          _this.xOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'xOff').onChange(function(val) {
        _this.xOff = val;
        if (_this.xOff) {
          if (_this.xFollow) {
            _this.lastX = 'follow';
          } else if (_this.xBounce) {
            _this.lastX = 'bounce';
          } else if (_this.xLeft) {
            _this.lastX = 'left';
          } else if (_this.xRight) {
            _this.lastX = 'right';
          }
          _this.xFollow = _this.xBounce = _this.xLeft = _this.xRight = false;
        } else {
          if (_this.lastX === 'follow') {
            _this.xFollow = true;
          } else if (_this.lastX === 'bounce') {
            _this.xBounce = true;
          } else if (_this.lastX === 'left') {
            _this.xLeft = true;
          } else if (_this.lastX === 'right') {
            _this.xRight = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yFollow').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yFollow = true) {
          _this.yBounce = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'follow';
          _this.yBounce = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yBounce').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yBounce = true) {
          _this.yFollow = _this.yUp = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'bounce';
          _this.yFollow = _this.yUp = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yUp').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yUp = true) {
          _this.yDir = -1;
          _this.yFollow = _this.yBounce = _this.yDown = _this.yOff = false;
        } else {
          _this.lastY = 'left';
          _this.yFollow = _this.yBounce = _this.yDown = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yDown').onChange(function(val) {
        _this.yFollow = val;
        if (_this.yDown = true) {
          _this.yDir = 1;
          _this.yFollow = _this.yBounce = _this.yUp = _this.yOff = false;
        } else {
          _this.lastY = 'right';
          _this.yFollow = _this.yBounce = _this.yUp = false;
          _this.yOff = true;
        }
        return _this.updateGui();
      });
      this.gui.add(this, 'yOff').onChange(function(val) {
        _this.yOff = val;
        if (_this.yOff) {
          if (_this.yFollow) {
            _this.lastY = 'follow';
          } else if (_this.yBounce) {
            _this.lastY = 'bounce';
          } else if (_this.yUp) {
            _this.lastY = 'up';
          } else if (_this.yDown) {
            _this.lastY = 'down';
          }
          _this.yFollow = _this.yBounce = _this.yUp = _this.yDown = false;
        } else {
          if (_this.lastY === 'follow') {
            _this.yFollow = true;
          } else if (_this.lastY === 'bounce') {
            _this.yBounce = true;
          } else if (_this.lastY === 'up') {
            _this.yUp = true;
          } else if (_this.lastY === 'down') {
            _this.yDown = true;
          }
        }
        return _this.updateGui();
      });
      this.gui.close();
    }
    Dots.__super__.load.call(this);
    this.view.appendChild(this.renderer.view);
    this.xLimit = this.dots.length;
    this.yLimit = this.dots[0].length;
    window.onmousemove = this.handleMouseMove;
    return null;
  };

  Dots.prototype.unload = function() {
    Dots.__super__.unload.call(this);
    window.onmousemove = null;
    return null;
  };

  Dots.prototype.update = function() {
    var i, j, sprite, tgtAlpha, _i, _j, _ref, _ref1;
    Dots.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (this.xFollow) {
      this.xCounter = this.curX;
    }
    if (this.yFollow) {
      this.yCounter = this.curY;
    }
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        sprite = this.dots[i][j];
        tgtAlpha = 1;
        if (this.invert) {
          tgtAlpha = 0;
        }
        if (!this.xOff && i === this.xCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (!this.yOff && j === this.yCounter) {
          sprite.alpha = tgtAlpha;
          sprite.scale.x = sprite.scale.y = tgtAlpha * (this.spriteSize / 32);
        }
        if (this.invert) {
          if (sprite.alpha < 1) {
            sprite.alpha += 0.05;
            sprite.scale.x += 0.05;
            sprite.scale.y += 0.05;
            if (sprite.alpha > 1) {
              sprite.alpha = 1;
            }
            if (sprite.scale.x > 1) {
              sprite.scale.x = sprite.scale.y = this.spriteSize / 32;
            }
          }
        } else {
          if (sprite.alpha > 0) {
            sprite.alpha -= 0.05;
            sprite.scale.x -= 0.05;
            sprite.scale.y -= 0.05;
            if (sprite.alpha < 0) {
              sprite.alpha = 0;
            }
            if (sprite.scale.x < 0) {
              sprite.scale.x - (sprite.scale.y = 0);
            }
          }
        }
      }
    }
    if (!this.xOff) {
      this.xCounter += this.xDir;
      if (this.xLeft || this.xRight) {
        this.xCounter %= this.xLimit;
        if (this.xCounter < 0) {
          this.xCounter = this.xLimit - 1;
        }
      } else if (this.xBounce) {
        if (this.xCounter === this.xLimit) {
          this.xCounter = this.xLimit - 2;
          this.xDir *= -1;
        } else if (this.xCounter < 0) {
          this.xCounter = 1;
          this.xDir *= -1;
        }
      }
    }
    if (!this.yOff) {
      this.yCounter += this.yDir;
      if (this.yUp || this.yDown) {
        this.yCounter %= this.yLimit;
        if (this.yCounter < 0) {
          this.yCounter = this.yLimit - 1;
        }
      } else if (this.yBounce) {
        if (this.yCounter === this.yLimit) {
          this.yCounter = this.yLimit - 2;
          this.yDir *= -1;
        } else if (this.yCounter < 0) {
          this.yCounter = 1;
          this.yDir *= -1;
        }
      }
    }
    this.easeX += (this.mouseX - this.easeX) / 45;
    this.easeY += (this.mouseY - this.easeY) / 45;
    this.curX = Math.floor(this.easeX / this.spriteSize);
    this.curY = Math.floor(this.easeY / this.spriteSize);
    this.renderer.render(this.stage);
    return null;
  };

  Dots.prototype.resize = function() {
    var i, j, _i, _j, _ref, _ref1;
    if (this.loaded) {
      for (i = _i = _ref = this.dots.length - 1; _i >= 0; i = _i += -1) {
        for (j = _j = _ref1 = this.dots[i].length - 1; _j >= 0; j = _j += -1) {
          this.stage.removeChild(this.dots[i][j]);
          this.dots[i].splice(j, 1);
        }
      }
      this.dots = [];
      this.createSprites();
      this.xLimit = this.dots.length;
      this.yLimit = this.dots[0].length;
    }
    return null;
  };

  Dots.prototype.handleMouseMove = function(e) {
    var tgtAlpha, xid, yid;
    this.mouseX = e.pageX;
    this.mouseY = e.pageY;
    if (this.mouseTrail) {
      xid = Math.floor(this.mouseX / this.spriteSize);
      yid = Math.floor(this.mouseY / this.spriteSize);
      tgtAlpha = 1;
      if (this.invert) {
        tgtAlpha = 0;
      }
      this.dots[xid][yid].alpha = tgtAlpha;
      if (this.dots[xid] && this.dots[xid][yid - 1]) {
        this.dots[xid][yid - 1].alpha = tgtAlpha;
        this.dots[xid][yid - 1].scale.x = this.dots[xid][yid - 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid] && this.dots[xid][yid + 1]) {
        this.dots[xid][yid + 1].alpha = tgtAlpha;
        this.dots[xid][yid + 1].scale.x = this.dots[xid][yid + 1].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid - 1] && this.dots[xid - 1][yid]) {
        this.dots[xid - 1][yid].alpha = tgtAlpha;
        this.dots[xid - 1][yid].scale.x = this.dots[xid - 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
      if (this.dots[xid + 1] && this.dots[xid + 1][yid]) {
        this.dots[xid + 1][yid].alpha = tgtAlpha;
        this.dots[xid + 1][yid].scale.x = this.dots[xid + 1][yid].scale.y = tgtAlpha * (this.spriteSize / 32);
      }
    }
    return null;
  };

  Dots.prototype.createSprites = function() {
    var i, j, sp, _i, _j, _ref, _ref1;
    this.xCount = Math.round(window.innerWidth / this.spriteSize);
    this.yCount = Math.round(window.innerHeight / this.spriteSize);
    for (i = _i = 0, _ref = this.xCount; _i <= _ref; i = _i += 1) {
      this.dots[i] = [];
      for (j = _j = 0, _ref1 = this.yCount; _j <= _ref1; j = _j += 1) {
        if (this.deadDots.length === 0) {
          sp = new PIXI.Sprite(window.app.textures[0]);
        } else {
          sp = this.deadDots[0];
          this.deadDots.splice(0, 1);
        }
        sp.scale.x = sp.scale.y = this.spriteSize / 32;
        sp.position.x = i * this.spriteSize;
        sp.position.y = j * this.spriteSize;
        this.dots[i][j] = sp;
        sp.alpha = 0;
        this.stage.addChild(sp);
      }
    }
    return null;
  };

  return Dots;

})(Sketch);

Fractals = (function(_super) {
  __extends(Fractals, _super);

  Fractals.prototype.minSize = 32;

  Fractals.prototype.startSize = 400;

  Fractals.prototype.divisor = 2.5;

  Fractals.prototype.sprites = [];

  Fractals.prototype.deadSprites = [];

  function Fractals(renderer) {
    this.renderer = renderer;
    this.getSprite = __bind(this.getSprite, this);
    this.addSprite = __bind(this.addSprite, this);
    this.redraw = __bind(this.redraw, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Fractals.__super__.constructor.call(this, this.renderer);
  }

  Fractals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderView = new PIXI.Sprite(this.renderTex);
      this.stage.addChild(this.renderView);
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.canvas = new PIXI.DisplayObjectContainer();
      this.gui.add(this, 'minSize', 1, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'startSize', 10, 1000).listen().onChange(function() {
        if (_this.startSize < _this.minSize) {
          return _this.minSize = _this.startSize;
        }
      }).onFinishChange(function() {
        return _this.redraw();
      });
      this.gui.add(this, 'divisor', 2, 6).onFinishChange(function() {
        return _this.redraw();
      });
    }
    this.createSprites();
    this.view.appendChild(this.renderer.view);
    Fractals.__super__.load.call(this);
    return null;
  };

  Fractals.prototype.unload = function() {
    Fractals.__super__.unload.call(this);
    return null;
  };

  Fractals.prototype.update = function() {
    Fractals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.renderer.render(this.stage);
    return null;
  };

  Fractals.prototype.resize = function() {
    this.redraw();
    return null;
  };

  Fractals.prototype.redraw = function() {
    this.renderTex.destroy();
    this.renderTex = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
    this.renderView.setTexture(this.renderTex);
    this.sprites = [];
    this.createSprites();
    return null;
  };

  Fractals.prototype.createSprites = function() {
    this.addSprite(window.innerWidth * 0.5, window.innerHeight * 0.5, this.startSize);
    return null;
  };

  Fractals.prototype.addSprite = function(x, y, size) {
    var _this = this;
    this.sprite.position.x = x;
    this.sprite.position.y = y;
    this.sprite.scale.x = this.sprite.scale.y = size / 32;
    this.canvas.addChild(this.sprite);
    this.renderTex.render(this.canvas);
    this.canvas.removeChild(this.sprite);
    if (size > this.minSize) {
      return setTimeout(function() {
        _this.addSprite(x + size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x - size / _this.divisor, y, size / _this.divisor);
        _this.addSprite(x, y + size / _this.divisor, size / _this.divisor);
        return _this.addSprite(x, y - size / _this.divisor, size / _this.divisor);
      }, 500);
    }
  };

  Fractals.prototype.getSprite = function() {
    if (this.deadSprites.length === 0) {
      return new PIXI.Sprite(window.app.textures[0]);
    } else {
      return this.deadSprites.splice(0, 1)[0];
    }
  };

  return Fractals;

})(Sketch);

Orbits = (function(_super) {
  __extends(Orbits, _super);

  function Orbits(renderer) {
    this.renderer = renderer;
    this.drawTail = __bind(this.drawTail, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Orbits.__super__.constructor.call(this, this.renderer);
  }

  Orbits.prototype.load = function() {
    var i, n, tx, ty, _i, _ref;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 19.6;
      this.baseNode.yIncrement = 35.2;
      this.baseNode.xOffset = 726;
      this.baseNode.yOffset = 217;
      this.numSattelites = 10;
      this.easing = 50;
      this.tailLength = 60;
      this.tailWidth = 6.2;
      this.initialSpacing = 60;
      this.nodes = [];
      this.maxSpeed = 175;
      this.tailColour = 0x8CF1FF;
      for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        tx = this.midx + (Math.cos(Math.random() * Math.PI) * this.initialSpacing);
        ty = this.midy + (Math.sin(Math.random() * Math.PI) * this.initialSpacing);
        n = new Node(tx, ty);
        n.recordedPositions = this.tailLength;
        n.fillPositions();
        this.nodes.push(n);
      }
      this.graphics = new PIXI.Graphics();
      this.stage.addChild(this.graphics);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this, 'tailWidth', 2, 100);
      this.gui.add(this, 'maxSpeed', 2, 1000);
      this.gui.add(this, 'easing', 2, 100);
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
    }
    this.view.appendChild(this.renderer.view);
    Orbits.__super__.load.call(this);
    return null;
  };

  Orbits.prototype.unload = function() {
    Orbits.__super__.unload.call(this);
    return null;
  };

  Orbits.prototype.update = function() {
    var i, n, newx, newy, xdif, ydif, _i, _ref;
    Orbits.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.graphics.clear();
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(this.baseNode.xSin * window.app.degToRad) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(this.baseNode.ySin * window.app.degToRad) * this.baseNode.yOffset);
    for (i = _i = 0, _ref = this.numSattelites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = this.nodes[i];
      xdif = this.baseNode.position.x - n.position.x;
      ydif = this.baseNode.position.y - n.position.y;
      n.velocity.x += xdif / this.easing;
      n.velocity.y += ydif / this.easing;
      if (n.velocity.x > this.maxSpeed) {
        n.velocity.x = this.maxSpeed;
      } else if (n.velocity.x < -this.maxSpeed) {
        n.velocity.x = -this.maxSpeed;
      }
      if (n.velocity.y > this.maxSpeed) {
        n.velocity.y = this.maxSpeed;
      } else if (n.velocity.y < -this.maxSpeed) {
        n.velocity.y = -this.maxSpeed;
      }
      newx = n.position.x + n.velocity.x;
      newy = n.position.y + n.velocity.y;
      n.moveTo(newx, newy);
      this.drawTail(n);
    }
    this.renderer.render(this.stage);
    return null;
  };

  Orbits.prototype.resize = function() {
    return null;
  };

  Orbits.prototype.drawTail = function(node) {
    var i, inc, pt1, pt2, tailInc, _i, _ref;
    inc = 1 / this.tailLength;
    tailInc = this.tailWidth / this.tailLength;
    for (i = _i = 0, _ref = this.tailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.tailWidth > 1) {
        this.graphics.lineStyle(tailInc * i, this.tailColour, i * inc);
      } else {
        this.graphics.lineStyle(this.tailWidth, this.tailColour, i * inc);
      }
      pt1 = node.positions[i];
      pt2 = node.positions[i + 1];
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt2.x, pt2.y);
    }
    return null;
  };

  return Orbits;

})(Sketch);

Radar = (function(_super) {
  __extends(Radar, _super);

  Radar.prototype.numSprites = 60;

  Radar.prototype.radarWidth = 579;

  Radar.prototype.minScale = 0.1;

  Radar.prototype.maxScale = 0.3;

  Radar.prototype.rotation = 0;

  Radar.prototype.rotationSpeed = 238;

  Radar.prototype.midX = 400;

  Radar.prototype.midY = 300;

  Radar.prototype.sprites = [];

  function Radar(renderer) {
    this.renderer = renderer;
    this.createSprites = __bind(this.createSprites, this);
    this.scaleSprites = __bind(this.scaleSprites, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Radar.__super__.constructor.call(this, this.renderer);
    this.midX = window.innerWidth * 0.5;
    this.midY = window.innerHeight * 0.5;
  }

  Radar.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'rotationSpeed', 0.1, 359.9);
      this.gui.add(this, 'radarWidth', 10, 1000);
      this.gui.add(this, 'minScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.gui.add(this, 'maxScale', 0.1, 10).onFinishChange(function() {
        return _this.scaleSprites();
      });
      this.holder = new PIXI.DisplayObjectContainer();
      this.renderTexture = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.renderTexture2 = new PIXI.RenderTexture(window.innerWidth, window.innerHeight);
      this.dummy = new PIXI.Graphics();
      this.dummy.beginFill(0x000000, 0.05);
      this.dummy.drawRect(0, 0, window.innerWidth, window.innerHeight);
      this.currentTexture = this.renderTexture;
      this.canvas = new PIXI.Sprite(this.currentTexture);
      this.holder.addChild(this.canvas);
      this.stage.addChild(this.holder);
      this.createSprites();
    }
    this.view.appendChild(this.renderer.view);
    Radar.__super__.load.call(this);
    return null;
  };

  Radar.prototype.unload = function() {
    Radar.__super__.unload.call(this);
    return null;
  };

  Radar.prototype.update = function() {
    var i, rot, temp, _i, _ref;
    Radar.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.rotation += this.rotationSpeed;
    rot = this.rotation * window.app.degToRad;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = this.sprites[i];
      this.sprite.position.x = this.midX + (Math.cos(rot) * ((this.radarWidth / this.numSprites) * i));
      this.sprite.position.y = this.midY + (Math.sin(rot) * ((this.radarWidth / this.numSprites) * i));
    }
    temp = this.renderTexture;
    this.renderTexture = this.renderTexture2;
    this.renderTexture2 = temp;
    this.canvas.setTexture(this.renderTexture);
    this.renderTexture2.render(this.holder, new PIXI.Point(0, 0), false);
    this.renderTexture2.render(this.dummy, new PIXI.Point(0, 0), false);
    this.renderer.render(this.stage);
    return null;
  };

  Radar.prototype.resize = function() {
    return null;
  };

  Radar.prototype.scaleSprites = function() {
    var i, tgtScale, _i, _ref;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      tgtScale = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      TweenMax.to(this.sprites[i].scale, 2, {
        x: tgtScale,
        y: tgtScale,
        ease: Bounce.easeOut
      });
    }
    return null;
  };

  Radar.prototype.createSprites = function() {
    var i, rot, rotInc, _i, _ref;
    rotInc = 360 / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.sprite = new PIXI.Sprite(window.app.textures[0]);
      this.sprite.pivot.x = this.sprite.pivot.y = 16;
      this.sprite.scale.x = this.sprite.scale.y = this.minScale + (Math.random() * (this.maxScale - this.minScale));
      rot = (i * rotInc) * window.app.degToRad;
      this.sprite.position.x = this.midX + ((this.radarWidth / this.numSprites) * i);
      this.sprite.position.y = this.midY;
      this.holder.addChild(this.sprite);
      this.sprites.push(this.sprite);
    }
    return null;
  };

  return Radar;

})(Sketch);

Ribbon = (function(_super) {
  __extends(Ribbon, _super);

  function Ribbon(renderer) {
    this.renderer = renderer;
    this.drawRibbon = __bind(this.drawRibbon, this);
    this.updateTrails = __bind(this.updateTrails, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Ribbon.__super__.constructor.call(this, this.renderer);
  }

  Ribbon.prototype.load = function() {
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.midx = window.innerWidth * 0.5;
      this.midy = window.innerHeight * 0.5;
      this.baseNode = new Node(this.midx, this.midy);
      this.baseNode.xSin = 0;
      this.baseNode.ySin = 0;
      this.baseNode.xIncrement = 2.9;
      this.baseNode.yIncrement = 3.7;
      this.baseNode.xOffset = 470;
      this.baseNode.yOffset = 220;
      this.ribbonWidth = 200;
      this.trailLength = 60;
      this.tailColour = 0xFFFFFF;
      this.nodeA = new Node(this.baseNode.position.x, this.baseNode.position.y - this.ribbonWidth);
      this.nodeB = new Node(this.baseNode.position.x, this.baseNode.position.y + this.ribbonWidth);
      this.nodeA.recordedPositions = this.nodeB.recordedPositions = this.trailLength;
      this.nodeA.fillPositions();
      this.nodeB.fillPositions();
      this.nodeA.sin = 0;
      this.nodeB.sin = 0;
      this.nodeA.inc = 4.6;
      this.nodeB.inc = 3.2;
      this.graphics = new PIXI.Graphics();
      this.tailA = [];
      this.tailB = [];
      this.stage.addChild(this.graphics);
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'ribbonWidth', 1, 200);
      this.gui.addColor(this, 'tailColour');
      this.gui.add(this.baseNode, 'xOffset', 0, 1000);
      this.gui.add(this.baseNode, 'yOffset', 0, 1000);
      this.gui.add(this.baseNode, 'xIncrement', 0.1, 359.9);
      this.gui.add(this.baseNode, 'yIncrement', 0.1, 359.9);
      this.gui.add(this.nodeA, 'inc', 0.1, 359.9);
      this.gui.add(this.nodeB, 'inc', 0.1, 359.9);
    }
    this.view.appendChild(this.renderer.view);
    Ribbon.__super__.load.call(this);
    return null;
  };

  Ribbon.prototype.unload = function() {
    Ribbon.__super__.unload.call(this);
    return null;
  };

  Ribbon.prototype.update = function() {
    var ty;
    Ribbon.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.baseNode.xSin += this.baseNode.xIncrement;
    this.baseNode.xSin %= 360;
    this.baseNode.ySin += this.baseNode.yIncrement;
    this.baseNode.ySin %= 360;
    this.baseNode.position.x = this.midx + (Math.cos(this.baseNode.xSin * window.app.degToRad) * this.baseNode.xOffset);
    this.baseNode.position.y = this.midy + (Math.cos(this.baseNode.ySin * window.app.degToRad) * this.baseNode.yOffset);
    this.nodeA.sin += this.nodeA.inc;
    this.nodeA.sin %= 360;
    ty = this.baseNode.position.y - (Math.sin(this.nodeA.sin * window.app.degToRad) * this.ribbonWidth);
    this.nodeA.moveTo(this.baseNode.position.x, ty);
    this.nodeB.sin += this.nodeB.inc;
    this.nodeB.sin %= 360;
    ty = this.baseNode.position.y + (Math.sin(this.nodeB.sin * window.app.degToRad) * this.ribbonWidth);
    this.nodeB.moveTo(this.baseNode.position.x, ty);
    this.drawRibbon();
    this.renderer.render(this.stage);
    return null;
  };

  Ribbon.prototype.resize = function() {
    return null;
  };

  Ribbon.prototype.updateTrails = function() {
    var i, sp, _i, _ref;
    for (i = _i = 0, _ref = this.trailLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      sp = this.tailA[i];
      sp.position.x = this.nodeA.positions[i].x;
      sp.position.y = this.nodeA.positions[i].y;
      sp = this.tailB[i];
      sp.position.x = this.nodeB.positions[i].x;
      sp.position.y = this.nodeB.positions[i].y;
    }
    return null;
  };

  Ribbon.prototype.drawRibbon = function() {
    var i, inc, pt1, pt2, pt3, pt4, _i, _ref;
    this.graphics.clear();
    inc = 1 / this.trailLength;
    for (i = _i = 0, _ref = this.trailLength - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      pt1 = this.nodeA.positions[i];
      pt2 = this.nodeB.positions[i];
      pt3 = this.nodeA.positions[i + 1];
      pt4 = this.nodeB.positions[i + 1];
      this.graphics.beginFill(this.tailColour, i * inc);
      this.graphics.moveTo(pt1.x, pt1.y);
      this.graphics.lineTo(pt3.x, pt3.y);
      this.graphics.lineTo(pt4.x, pt4.y);
      this.graphics.lineTo(pt2.x, pt2.y);
      this.graphics.endFill();
    }
    return null;
  };

  return Ribbon;

})(Sketch);

MathUtils = (function() {
  function MathUtils() {}

  MathUtils.degToRadValue = Math.PI / 180;

  MathUtils.radToDegValue = 180 / Math.PI;

  MathUtils.twoPI = 2 * Math.PI;

  MathUtils.degToRad = function(val) {
    return val * MathUtils.degToRadValue;
  };

  MathUtils.radToDeg = function(val) {
    return val * MathUtils.radToDegValue;
  };

  return MathUtils;

})();

SineWave = (function(_super) {
  __extends(SineWave, _super);

  SineWave.id = 'Sine Wave';

  SineWave.prototype.phase = 0;

  SineWave.prototype.limit = 360;

  SineWave.prototype.waveLength = 203;

  SineWave.prototype.amplitude = 260;

  SineWave.prototype.frequency = 10;

  SineWave.prototype.rotateAngle = 0;

  SineWave.prototype.rotateSpeed = 351.16;

  SineWave.prototype.numSprites = 100;

  SineWave.prototype.midY = 0;

  SineWave.prototype.sprites = [];

  function SineWave(renderer) {
    this.renderer = renderer;
    this.createSprites = __bind(this.createSprites, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    SineWave.__super__.constructor.call(this, this.renderer);
  }

  SineWave.prototype.load = function() {
    this.midY = window.innerHeight * 0.5;
    this.midX = window.innerWidth * 0.5;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'waveLength', 10, 1000);
      this.gui.add(this, 'amplitude', 10, 500);
      this.gui.add(this, 'frequency', 1, 100);
      this.gui.add(this, 'limit', 1, 360);
      this.gui.add(this, 'rotateSpeed', 0, 720);
      this.gui.close();
    }
    this.view.appendChild(this.renderer.view);
    SineWave.__super__.load.call(this);
    return null;
  };

  SineWave.prototype.unload = function() {
    SineWave.__super__.unload.call(this);
    return null;
  };

  SineWave.prototype.update = function() {
    var angle, i, newx, newy, sp, spacing, xCalc, xPos, xSin, yCalc, yPos, _i, _ref;
    SineWave.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = this.sprites[i];
      xPos = (i * spacing) + ((this.phase / 360) * this.waveLength);
      xSin = ((xPos % this.waveLength) / this.waveLength) * 360;
      yPos = this.midY + (Math.sin(MathUtils.degToRad(xSin)) * this.amplitude);
      xCalc = xPos - this.midX;
      yCalc = yPos - this.midY;
      angle = MathUtils.degToRad(this.rotateAngle);
      newx = (xCalc * Math.cos(angle)) - (yCalc * Math.sin(angle));
      newy = (xCalc * Math.sin(angle)) + (yCalc * Math.cos(angle));
      sp.position.x = this.midX + newx;
      sp.position.y = this.midY + newy;
    }
    this.phase += this.frequency;
    this.phase %= this.limit;
    this.rotateAngle += this.rotateSpeed;
    this.rotateAngle %= 360;
    this.renderer.render(this.stage);
    return null;
  };

  SineWave.prototype.createSprites = function() {
    var i, sp, spacing, _i, _ref;
    spacing = window.innerWidth / this.numSprites;
    for (i = _i = 0, _ref = this.numSprites; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(window.app.textures[0]);
      sp.pivot.x = sp.pivot.y = 16;
      sp.position.x = i * spacing;
      sp.position.y = this.midY;
      this.sprites.push(sp);
      this.stage.addChild(sp);
    }
    return null;
  };

  return SineWave;

})(Sketch);

Node = (function() {
  function Node(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.fillPositions = __bind(this.fillPositions, this);
    this.checkPositionsLength = __bind(this.checkPositionsLength, this);
    this.moveTo = __bind(this.moveTo, this);
    this.position = new Point(x, y, z);
    this.velocity = new Point();
    this.positions = [];
    this.positions.push(this.position.clone());
    this.recordedPositions = 1;
  }

  Node.prototype.moveTo = function(x, y, z) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (z == null) {
      z = 0;
    }
    this.position.x = x;
    this.position.y = y;
    this.position.z = z;
    this.positions.push(this.position.clone());
    this.checkPositionsLength();
    return null;
  };

  Node.prototype.checkPositionsLength = function() {
    while (this.positions.length > this.recordedPositions) {
      this.positions.splice(0, 1);
    }
    return null;
  };

  Node.prototype.fillPositions = function() {
    while (this.positions.length < this.recordedPositions) {
      this.positions.push(this.position.clone());
    }
    return null;
  };

  return Node;

})();

Point = (function() {
  function Point(x, y, z) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
    this.z = z != null ? z : 0;
    this.toString = __bind(this.toString, this);
    this.clone = __bind(this.clone, this);
  }

  Point.prototype.clone = function() {
    return new Point(this.x, this.y, this.z);
  };

  Point.prototype.toString = function() {
    return 'Point [x:' + this.x + ', y:' + this.y + ', z:' + this.z + ']';
  };

  return Point;

})();

Smoky = (function(_super) {
  __extends(Smoky, _super);

  Smoky.id = 'Smoky';

  Smoky.prototype.numNodes = 200;

  Smoky.prototype.checkDist = 100;

  Smoky.prototype.checkDistSq = 0;

  Smoky.prototype.nodes = [];

  Smoky.prototype.sprites = [];

  function Smoky(renderer) {
    this.renderer = renderer;
    this.mouseMove = __bind(this.mouseMove, this);
    this.update = __bind(this.update, this);
    this.resize = __bind(this.resize, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    this.checkDistSq = this.checkDist * this.checkDist;
    Smoky.__super__.constructor.call(this, this.renderer);
  }

  Smoky.prototype.load = function() {
    if (this.loaded) {
      window.onmousemove = this.mouseMove;
      this.windowWidth = window.innerWidth;
      this.windowHeight = window.innerHeight;
      this.areaWidth = this.windowWidth + 400;
      this.areaHeight = this.windowHeight + 400;
      this.view.appendChild(this.renderer.view);
      Smoky.__super__.load.call(this);
      return;
    }
    this.windowWidth = window.innerWidth;
    this.windowHeight = window.innerHeight;
    this.areaWidth = this.windowWidth + 400;
    this.areaHeight = this.windowHeight + 400;
    this.stage = new PIXI.Stage(window.app.stageColor);
    this.view = document.createElement('div');
    this.view.appendChild(this.renderer.view);
    this.createNodes();
    this.createSprites();
    window.onmousemove = this.mouseMove;
    return Smoky.__super__.load.call(this);
  };

  Smoky.prototype.unload = function() {
    window.onmousemove = null;
    Smoky.__super__.unload.call(this);
    return null;
  };

  Smoky.prototype.resize = function() {
    return null;
  };

  Smoky.prototype.createNodes = function() {
    var i, n, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      n = new Node(Math.random() * this.windowWidth, Math.random() * this.windowHeight);
      n.velocity.x = 3 - (6 * Math.random());
      n.velocity.y = 3 - (6 * Math.random());
      n.sinPos = Math.random() * 360;
      n.sinIncrement = Math.random() * 0.5;
      n.scaleAmount = Math.random() * 2;
      this.nodes.push(n);
    }
    return null;
  };

  Smoky.prototype.createSprites = function() {
    var i, sp, _i, _ref;
    this.tex = window.app.textures[0];
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      sp = new PIXI.Sprite(this.tex);
      sp.pivot.x = 16;
      sp.pivot.y = 16;
      sp.blendMode = PIXI.blendModes.SCREEN;
      sp.alpha = 0.1 + (Math.random() * 0.2);
      this.sprites.push(sp);
      this.stage.addChild(sp);
    }
    return null;
  };

  Smoky.prototype.updateSprites = function() {
    var distTo, i, node, sp, _i, _ref;
    for (i = _i = 0, _ref = this.numNodes; _i <= _ref; i = _i += 1) {
      node = this.nodes[i];
      node.position.x += node.velocity.x;
      node.position.y += node.velocity.y;
      node.sinPos += node.sinIncrement;
      node.sinPos %= 360;
      node.scale = 10 + (Math.sin(node.sinPos * (Math.PI / 180)) * node.scaleAmount);
      if (node.position.x > this.windowWidth + 200) {
        node.position.x -= this.areaWidth;
      } else if (node.position.x < -200) {
        node.position.x += this.areaWidth;
      }
      if (node.position.y > this.windowHeight + 200) {
        node.position.y -= this.areaHeight;
      } else if (node.position.y < -200) {
        node.position.y += this.areaHeight;
      }
      distTo = this.distanceTo({
        x: node.position.x,
        y: node.position.y
      }, {
        x: this.curX,
        y: this.curY
      });
      if (distTo.dist < this.checkDistSq) {
        node.velocity.x = ((distTo.xDif * -1) / this.checkDist) * 5;
        node.velocity.y = ((distTo.yDif * -1) / this.checkDist) * 5;
      }
      sp = this.sprites[i];
      sp.position.x = node.position.x;
      sp.position.y = node.position.y;
      sp.scale.x = sp.scale.y = node.scale;
    }
    return null;
  };

  Smoky.prototype.distanceTo = function(object, target) {
    var xDif, yDif;
    xDif = target.x - object.x;
    yDif = target.y - object.y;
    return {
      xDif: xDif,
      yDif: yDif,
      dist: (xDif * xDif) + (yDif * yDif)
    };
  };

  Smoky.prototype.update = function() {
    Smoky.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.updateSprites();
    this.renderer.render(this.stage);
    return null;
  };

  Smoky.prototype.mouseMove = function(e) {
    this.curX = e.pageX;
    this.curY = e.pageY;
    return null;
  };

  return Smoky;

})(Sketch);

Spirals = (function(_super) {
  __extends(Spirals, _super);

  Spirals.id = 'Spirals';

  Spirals.prototype.midPoint = null;

  Spirals.prototype.nodes = [];

  Spirals.prototype.deadNodes = [];

  Spirals.prototype.newNodeCount = 1;

  Spirals.prototype.newNodeLimit = 10;

  Spirals.prototype.changeCount = 720;

  Spirals.prototype.changeLimit = 720;

  Spirals.prototype.rotateSpeed = 11;

  Spirals.prototype.moveSpeed = 0.6;

  Spirals.prototype.sqDist = 100;

  function Spirals(renderer) {
    this.renderer = renderer;
    this.createSprite = __bind(this.createSprite, this);
    this.createNode = __bind(this.createNode, this);
    this.distToMidpoint = __bind(this.distToMidpoint, this);
    this.updateNodes = __bind(this.updateNodes, this);
    this.randomisePattern = __bind(this.randomisePattern, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Spirals.__super__.constructor.call(this, this.renderer);
  }

  Spirals.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'rotateSpeed', -50, 50).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.add(this, 'moveSpeed', 0.1, 10).listen().onChange(function() {
        return _this.changeCount = _this.changeLimit;
      });
      this.gui.close();
    }
    this.midPoint = {
      x: window.innerWidth * 0.5,
      y: window.innerHeight * 0.5
    };
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    this.view.appendChild(this.renderer.view);
    this.randomisePattern();
    Spirals.__super__.load.call(this);
    return null;
  };

  Spirals.prototype.unload = function() {
    Spirals.__super__.unload.call(this);
    return null;
  };

  Spirals.prototype.update = function() {
    var newNode;
    Spirals.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    if (window.app.spacePressed) {
      this.changeCount = this.changeLimit;
      window.app.spacePressed = false;
      this.randomisePattern();
    }
    this.newNodeCount--;
    if (this.newNodeCount === 0) {
      this.newNodeCount = this.newNodeLimit;
      newNode = this.createNode();
      this.nodes.push(newNode);
      this.stage.addChild(newNode.sprite);
    }
    this.changeCount--;
    if (this.changeCount === 0) {
      this.randomisePattern();
      this.changeCount = this.changeLimit;
    }
    this.updateNodes();
    this.renderer.render(this.stage);
    return null;
  };

  Spirals.prototype.resize = function() {
    this.midPoint.x = window.innerWidth * 0.5;
    this.midPoint.y = window.innerHeight * 0.5;
    this.sqDist = (window.innerWidth * 0.5) * (window.innerWidth * 0.5);
    return null;
  };

  Spirals.prototype.randomisePattern = function() {
    TweenMax.to(this, 0.5, {
      rotateSpeed: -50 + (Math.random() * 100),
      ease: Power4.easeOut
    });
    TweenMax.to(this, 0.5, {
      moveSpeed: Math.random() * 3,
      ease: Power4.easeOut
    });
    return null;
  };

  Spirals.prototype.updateNodes = function() {
    var angle, i, newx, newy, node, _i, _ref;
    for (i = _i = _ref = this.nodes.length - 1; _i >= 0; i = _i += -1) {
      node = this.nodes[i];
      node.y += this.moveSpeed;
      angle = MathUtils.degToRad(node.phase);
      newx = -node.y * Math.sin(angle);
      newy = node.y * Math.cos(angle);
      node.sprite.position.x = this.midPoint.x + newx;
      node.sprite.position.y = this.midPoint.y + newy;
      node.phase += this.rotateSpeed;
      node.phase %= 360;
      node.sprite.scale.x = node.sprite.scale.y = 0.25 + ((this.distToMidpoint(node) / this.sqDist) * 4);
      if ((newx - (16 * 5) + this.midPoint.x) > window.innerWidth) {
        this.stage.removeChild(node.sprite);
        this.nodes.splice(i, 1);
        this.deadNodes.push(node);
      }
    }
    return null;
  };

  Spirals.prototype.distToMidpoint = function(node) {
    var xDif, yDif;
    xDif = this.midPoint.x - node.sprite.position.x;
    yDif = this.midPoint.y - node.sprite.position.y;
    return (xDif * xDif) + (yDif * yDif);
  };

  Spirals.prototype.createNode = function() {
    var node;
    if (this.deadNodes.length === 0) {
      node = {
        y: 0,
        x: 0,
        sprite: this.createSprite(),
        phase: 0
      };
    } else {
      node = this.deadNodes[0];
      this.deadNodes.splice(0, 1);
      node.y = 0;
      node.x = 0;
      node.phase = 0;
    }
    return node;
  };

  Spirals.prototype.createSprite = function() {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = 16;
    sp.pivot.y = 16;
    return sp;
  };

  return Spirals;

})(Sketch);

Stacks = (function(_super) {
  __extends(Stacks, _super);

  Stacks.prototype.yCount = 30;

  Stacks.prototype.xCount = 40;

  Stacks.prototype.minSpeed = -40;

  Stacks.prototype.maxSpeed = 40;

  Stacks.prototype.tgtScale = 1;

  Stacks.prototype.nodes = [];

  Stacks.prototype.deadNodes = [];

  function Stacks(renderer) {
    this.renderer = renderer;
    this.randomiseSpeeds = __bind(this.randomiseSpeeds, this);
    this.resize = __bind(this.resize, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Stacks.__super__.constructor.call(this, this.renderer);
  }

  Stacks.prototype.load = function() {
    var _this = this;
    if (!this.loaded) {
      this.stage = new PIXI.Stage(window.app.stageColor);
      this.createSprites();
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      this.gui = this.makeGui();
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'minSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
      this.gui.add(this, 'maxSpeed', -40, 40).listen().onChange(function() {
        if (_this.maxSpeed < _this.minSpeed) {
          _this.minSpeed = _this.maxSpeed;
        }
        return _this.randomiseSpeeds();
      });
    }
    this.view.appendChild(this.renderer.view);
    Stacks.__super__.load.call(this);
    return null;
  };

  Stacks.prototype.unload = function() {
    Stacks.__super__.unload.call(this);
    return null;
  };

  Stacks.prototype.update = function() {
    Stacks.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    this.updateNodes();
    this.renderer.render(this.stage);
    return null;
  };

  Stacks.prototype.resize = function() {
    return null;
  };

  Stacks.prototype.updateNodes = function() {
    var i, j, newSpeed, node, totSpeed, winWidth, xdif, _i, _j, _ref, _ref1;
    winWidth = window.innerWidth;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        node = this.nodes[i][j];
        node.sprite.position.x += node.speed;
        if (node.sprite.position.x <= 0) {
          node.sprite.position.x = 0.1;
          node.speed *= -1;
        } else if (node.sprite.position.x >= winWidth) {
          node.sprite.position.x = winWidth - 0.1;
          node.speed *= -1;
        }
        if (this.nodes[i + 1]) {
          if (node.sprite.position.x >= this.nodes[i + 1][j].sprite.position.x - (16 * this.tgtScale)) {
            xdif = Math.abs(node.sprite.position.x - this.nodes[i + 1][j].sprite.position.x) - (16.2 * this.tgtScale);
            if (xdif < 0) {
              xdif *= -1;
            }
            newSpeed = this.nodes[i + 1][j].speed;
            totSpeed = newSpeed + node.speed;
            this.nodes[i + 1][j].speed = node.speed;
            node.speed = newSpeed;
            node.sprite.position.x -= xdif * 0.5;
            this.nodes[i + 1][j].sprite.position.x += xdif * 0.5;
            /*
            						ms 4
            						os 2
            						os / (ms + os)
            						2 / (4 + 2)
            */

          }
        }
      }
    }
    return null;
  };

  Stacks.prototype.createSprites = function() {
    var i, j, _i, _j, _ref, _ref1;
    this.tgtScale = (window.innerHeight / (this.yCount - 1)) / 30;
    this.nodes = [];
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.nodes[i] = [];
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j] = {
          sprite: this.addSprite(i, j),
          speed: 0
        };
      }
    }
    this.randomiseSpeeds();
    return null;
  };

  Stacks.prototype.addSprite = function(x, y) {
    var sp;
    sp = new PIXI.Sprite(window.app.textures[0]);
    sp.pivot.x = sp.pivot.y = 16;
    sp.position.x = x * (window.innerWidth / this.xCount);
    sp.position.y = y * (30 * this.tgtScale);
    sp.scale.x = sp.scale.y = this.tgtScale;
    this.stage.addChild(sp);
    return sp;
  };

  Stacks.prototype.randomiseSpeeds = function() {
    var i, j, speedDif, _i, _j, _ref, _ref1;
    speedDif = this.maxSpeed - this.minSpeed;
    for (i = _i = 0, _ref = this.xCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = this.yCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        this.nodes[i][j].speed = this.minSpeed + (Math.random() * speedDif);
      }
    }
    return null;
  };

  return Stacks;

})(Sketch);

Trails = (function(_super) {
  __extends(Trails, _super);

  Trails.id = 'Trails';

  Trails.prototype.trailLength = 70;

  Trails.prototype.sprites = [];

  Trails.prototype.positions = [];

  Trails.prototype.sinOffset = 0;

  Trails.prototype.sinIncrement = 0;

  Trails.prototype.maxScale = 4;

  Trails.prototype.minScale = 1;

  Trails.prototype.wobbleAngle = 17;

  function Trails(renderer) {
    this.renderer = renderer;
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.update = __bind(this.update, this);
    this.unload = __bind(this.unload, this);
    this.load = __bind(this.load, this);
    Trails.__super__.constructor.call(this, this.renderer);
    this.toAdd = 0.00000000001;
    this.sinIncrement = MathUtils.twoPI / 18;
  }

  Trails.prototype.load = function() {
    var i, sp, _i, _ref,
      _this = this;
    if (this.loaded) {
      this.gui.domElement.style.display = 'block';
      this.gui.close();
      this.view.appendChild(this.renderer.view);
      window.onmousemove = this.handleMouseMove;
      Trails.__super__.load.call(this);
    } else {
      this.curX = this.mouseX = window.innerWidth * 0.5;
      this.curY = this.mouseY = window.innerHeight * 0.5;
      this.stage = new PIXI.Stage(window.app.stageColor);
      for (i = _i = 0, _ref = this.trailLength - 1; _i <= _ref; i = _i += 1) {
        sp = new PIXI.Sprite(window.app.textures[0]);
        sp.alpha = 0;
        sp.pivot.x = 16;
        sp.pivot.y = 16;
        this.stage.addChild(sp);
        this.sprites.push(sp);
      }
      this.view = document.createElement('div');
      this.view.appendChild(this.renderer.view);
      window.onmousemove = this.handleMouseMove;
      this.gui = new dat.GUI({
        autoPlace: false
      });
      this.gui.domElement.style.zIndex = 100;
      this.gui.domElement.style.position = 'absolute';
      this.gui.domElement.style.top = 0;
      this.gui.domElement.style.left = 0;
      this.gui.domElement.style.height = 'auto';
      this.view.appendChild(this.gui.domElement);
      this.gui.add(this, 'sinIncrement', 0, MathUtils.twoPI / 5);
      this.gui.add(this, 'wobbleAngle', 0, 90);
      this.gui.add(this, 'maxScale', 0, 10).listen().onChange(function() {
        if (_this.maxScale < _this.minScale) {
          return _this.minScale = _this.maxScale;
        }
      });
      this.gui.add(this, 'minScale', 0, 10).listen().onChange(function() {
        if (_this.minScale > _this.maxScale) {
          return _this.maxScale = _this.minScale;
        }
      });
      this.gui.close();
      Trails.__super__.load.call(this);
    }
    return null;
  };

  Trails.prototype.unload = function() {
    window.onmousemove = null;
    this.gui.domElement.style.display = 'none';
    Trails.__super__.unload.call(this);
    return null;
  };

  Trails.prototype.update = function() {
    var angle, dist, newX, newY, p, pos, vecX, vecY, _i, _len, _ref;
    Trails.__super__.update.call(this);
    if (this.cancelled) {
      return;
    }
    angle = MathUtils.degToRad(Math.sin(this.sinOffset) * this.wobbleAngle);
    vecX = this.mouseX - this.curX;
    vecY = this.mouseY - this.curY;
    newX = (vecX * Math.cos(angle)) - (vecY * Math.sin(angle));
    newY = (vecX * Math.sin(angle)) + (vecY * Math.cos(angle));
    this.curX += newX / 100;
    this.curY += newY / 100;
    this.positions.push({
      x: this.curX,
      y: this.curY
    });
    if (this.positions.length > this.trailLength) {
      this.positions.splice(0, 1);
    }
    _ref = this.positions;
    for (p = _i = 0, _len = _ref.length; _i < _len; p = ++_i) {
      pos = _ref[p];
      this.sprites[p].scale.x = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].scale.y = this.minScale + ((p / this.trailLength) * this.maxScale);
      this.sprites[p].position.x = pos.x;
      this.sprites[p].position.y = pos.y;
      this.sprites[p].alpha = p / this.trailLength;
    }
    this.renderer.render(this.stage);
    dist = Math.sqrt((vecX * vecX) + (vecY * vecY));
    if (dist === 0) {
      dist = 1;
    }
    this.toAdd = MathUtils.degToRad(30 / dist);
    this.sinOffset += this.sinIncrement + this.toAdd;
    this.sinOffset %= MathUtils.twoPI;
    return null;
  };

  Trails.prototype.handleMouseMove = function(e) {
    this.mouseX = e.pageX;
    this.mouseY = e.pageY;
    return null;
  };

  return Trails;

})(Sketch);

InfoPanel = (function() {
  InfoPanel.prototype.view = null;

  InfoPanel.prototype.bg = null;

  InfoPanel.prototype.contentPanel = null;

  function InfoPanel() {
    this.resize = __bind(this.resize, this);
    this.bgClick = __bind(this.bgClick, this);
    this.hide = __bind(this.hide, this);
    this.show = __bind(this.show, this);
    this.view = $('#information-panel');
    this.bg = $('#information-panel-bg');
    this.contentPanel = $('#information-panel-content');
    document.getElementById('information-panel-bg').onclick = this.bgClick;
    $(this.bg).css('cursor', 'pointer');
    this.resize();
  }

  InfoPanel.prototype.show = function() {
    $(this.view).css('z-index', '2000');
    TweenMax.to(this.view, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  InfoPanel.prototype.hide = function() {
    var _this = this;
    TweenMax.to(this.view, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        return $(_this.view).css('z-index', '2');
      }
    });
    return null;
  };

  InfoPanel.prototype.bgClick = function() {
    window.app.handleInfoClick();
    return null;
  };

  InfoPanel.prototype.resize = function() {
    var xPos, yPos;
    xPos = (window.innerWidth - $(this.contentPanel).width()) * 0.5;
    yPos = (window.innerHeight - $(this.contentPanel).height()) * 0.5;
    console.log('RESIZING :: ' + xPos + ', ' + yPos);
    return null;
  };

  return InfoPanel;

})();

MenuButton = (function() {
  MenuButton.prototype.isActive = false;

  function MenuButton(title, id) {
    this.title = title;
    this.id = id;
    this.click = __bind(this.click, this);
    this.mouseout = __bind(this.mouseout, this);
    this.mouseover = __bind(this.mouseover, this);
    this.deselect = __bind(this.deselect, this);
    this.select = __bind(this.select, this);
    this.disable = __bind(this.disable, this);
    this.enable = __bind(this.enable, this);
    this.view = document.createElement('div');
    $(this.view).attr('class', 'menu-button-holder');
    this.view.innerHTML = "<p class='menu-button'>" + this.title + "</p>";
  }

  MenuButton.prototype.enable = function() {
    this.view.onmouseover = this.mouseover;
    this.view.onmouseout = this.mouseout;
    this.view.onclick = this.click;
    return null;
  };

  MenuButton.prototype.disable = function() {
    this.view.onmouseover = null;
    this.view.onmouseout = null;
    this.view.onclick = null;
    return null;
  };

  MenuButton.prototype.select = function() {
    this.mouseover();
    this.isActive = true;
    return null;
  };

  MenuButton.prototype.deselect = function() {
    this.isActive = false;
    this.mouseout();
    return null;
  };

  MenuButton.prototype.mouseover = function() {
    if (this.isActive) {
      return;
    }
    TweenMax.to(this.view, 0.3, {
      css: {
        color: 'rgb(255, 0, 61)',
        background: 'rgba(0,0,0,0.55)'
      }
    });
    return null;
  };

  MenuButton.prototype.mouseout = function() {
    if (this.isActive) {
      return;
    }
    TweenMax.to(this.view, 2, {
      css: {
        color: '#dedede',
        background: 'rgba(0,0,0,0)'
      }
    });
    return null;
  };

  MenuButton.prototype.click = function() {
    window.app.selectSketch(this.id);
    return null;
  };

  return MenuButton;

})();

Menu = (function() {
  Menu.prototype.buttons = [];

  function Menu(app, data) {
    this.app = app;
    this.data = data;
    this.handleDivOut = __bind(this.handleDivOut, this);
    this.handleDivOver = __bind(this.handleDivOver, this);
    this.disable = __bind(this.disable, this);
    this.enable = __bind(this.enable, this);
    this.menuPanel = document.getElementById('menu-panel');
    this.menuButtons = document.getElementById('menu-buttons');
    this.currentButton = document.getElementById('current-sketch');
    this.createButtons();
    $(this.currentButton).css('cursor', 'pointer');
    this.currentButton.onclick = this.app.handleMenuClick;
    this.buttons[this.app.currentSketch].select();
  }

  Menu.prototype.show = function() {
    $(this.menuPanel).css('z-index', '1200');
    TweenMax.to(this.menuPanel, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  Menu.prototype.hide = function() {
    var _this = this;
    TweenMax.to(this.menuPanel, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        return $(_this.menuPanel).css('z-index', '1');
      }
    });
    return null;
  };

  Menu.prototype.enable = function() {
    var but, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      but.enable();
    }
    return null;
  };

  Menu.prototype.disable = function() {
    var but, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      but.disable();
    }
    return null;
  };

  Menu.prototype.updateInfoContent = function() {
    var but, nextId, prevId, _i, _len, _ref,
      _this = this;
    prevId = this.app.currentSketch - 1;
    if (prevId < 0) {
      prevId = this.app.sketches.length - 1;
    }
    nextId = this.app.currentSketch + 1;
    if (nextId === this.app.sketches.length) {
      nextId = 0;
    }
    TweenMax.to(this.currentButton, 0.5, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        var i, _i, _ref, _results;
        _this.currentButton.innerHTML = '<h1 style="opacity:0">' + _this.data[_this.app.currentSketch].classId + '</h1><div id="current-sketch-content">' + _this.getSketchCopy() + '</div>';
        _this.currentHeader = _this.currentButton.getElementsByTagName('h1')[0];
        _this.currentHolder = document.getElementById('current-sketch-content');
        _this.paras = _this.currentHolder.getElementsByTagName('p');
        $(_this.currentButton).css('opacity', '1');
        TweenMax.to(_this.currentHeader, 0.5, {
          css: {
            opacity: 1
          },
          ease: Power4.easeOut
        });
        _results = [];
        for (i = _i = 0, _ref = _this.paras.length - 1; _i <= _ref; i = _i += 1) {
          if (i < _this.paras.length - 1) {
            _results.push(TweenMax.to(_this.paras[i], 0.5, {
              css: {
                opacity: 1
              },
              ease: Power4.easeOut,
              delay: 0.3 + (i * 0.2)
            }));
          } else {
            _results.push(TweenMax.to(_this.paras[i], 0.5, {
              css: {
                opacity: 1
              },
              ease: Power4.easeOut,
              delay: 0.3 + (i * 0.2),
              onComplete: function() {
                return console.log('ALL TWEENING DONE');
              }
            }));
          }
        }
        return _results;
      }
    });
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      but = _ref[_i];
      if (but.id !== this.app.currentSketch && but.isActive) {
        but.deselect();
      } else if (but.id === this.app.currentSketch && !but.isActive) {
        but.select();
      }
    }
    return null;
  };

  Menu.prototype.getSketchCopy = function() {
    var str;
    str = "<p class='information-panel-copy' style='opacity:0'>" + this.data[this.app.currentSketch].instructions + "</p>";
    str += "<p class='information-panel-copy' style='opacity:0'>" + this.data[this.app.currentSketch].description + "</p>";
    return str;
  };

  Menu.prototype.handleDivOver = function(e) {
    if (e.target === this.nextButton || e.target === this.menuButtons || e.target === this.currentButton) {
      TweenMax.to(e.target, 0.3, {
        css: {
          color: 'rgb(255, 0, 61)'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  Menu.prototype.handleDivOut = function(e) {
    if (e.target === this.nextButton || e.target === this.menuButtons || e.target === this.currentButton) {
      TweenMax.to(e.target, 2, {
        css: {
          color: '#dedede'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  Menu.prototype.createButtons = function() {
    var but, i, _i, _ref;
    for (i = _i = 0, _ref = this.data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      but = new MenuButton(this.data[i].classId, i);
      this.buttons.push(but);
      this.menuButtons.appendChild(but.view);
    }
    return null;
  };

  return Menu;

})();

PWPData = (function() {
  function PWPData() {}

  PWPData.prototype.data = [
    {
      className: Smoky,
      classId: "Smoky",
      description: "Everyone starts with particles, right? Anyway, I was mucking around with them and liked the sort of smoky, foggy look the sprite had when it was really big.",
      instructions: "Just wiggle your mouse about to disturb the smoke a little."
    }, {
      className: Trails,
      classId: "Trails",
      description: "Mouse trails are pretty ubiquitous too. This one looked more alive when I was wiggling my mouse, so I've added a heading vector that fluctuates across an angle spread. Smaller sizes work better on smaller screens.",
      instructions: "A simple mouse trail."
    }, {
      className: Dots,
      classId: "Dots",
      description: "I've always loved LED grids, chuck in some rhythmic patterns and they hypnotise me. I might come back to this and write an image/text parser for it.",
      instructions: "Lots of settings for this one\nHave a play"
    }, {
      className: Spirals,
      classId: "Spirals",
      description: "Nature is full of Spirals and they're lovely to look at. This one moves between random selections which alters the patterns produced. The strobing effect makes it look more complicated than it is and becomes almost kaleidoscopic. I may have stared at this one for hours.",
      instructions: "It changes automagically, but hitting space will force a new random selection"
    }, {
      className: SineWave,
      classId: "Sine Wave",
      description: "A lot of the previous experiments used sine values of some sort and they look pretty cool too. This one started out as a plain old sine wave, but I chucked in some rotation after staring at spirals and it makes some equally pleasing patterns when it strobes.",
      instructions: "Play with the settings in this one"
    }, {
      className: Stacks,
      classId: "Stacks",
      description: "It's sort of like an abacus.",
      instructions: "Just watch it"
    }, {
      className: Fractals,
      classId: "Fractals",
      description: "....",
      instructions: "...."
    }, {
      className: Radar,
      classId: "Radar",
      description: "....",
      instructions: "...."
    }, {
      className: Ribbon,
      classId: "Ribbon",
      description: "....",
      instructions: "...."
    }, {
      className: Orbits,
      classId: "Orbits",
      description: "....",
      instructions: "...."
    }
  ];

  return PWPData;

})();

App = (function() {
  App.prototype.sketches = null;

  App.prototype.data = null;

  App.prototype.currentSketch = 0;

  App.prototype.numSketches = null;

  App.prototype.liveSketch = null;

  App.prototype.textures = null;

  App.prototype.infoButton = null;

  App.prototype.menuButton = null;

  App.prototype.menuOpen = false;

  App.prototype.infoOpen = true;

  App.prototype.infoPanel = null;

  App.prototype.menuPanel = null;

  App.prototype.stageColor = 0x0a0a0a;

  App.prototype.spacePressed = false;

  App.prototype.degToRad = Math.PI / 180;

  App.prototype.radToDeg = 180 / Math.PI;

  function App() {
    this.selectSketch = __bind(this.selectSketch, this);
    this.prev = __bind(this.prev, this);
    this.next = __bind(this.next, this);
    this.handleKeyPress = __bind(this.handleKeyPress, this);
    this.handleInterfaceOver = __bind(this.handleInterfaceOver, this);
    this.handleInterfaceOut = __bind(this.handleInterfaceOut, this);
    this.handleMenuClick = __bind(this.handleMenuClick, this);
    this.handleInfoClick = __bind(this.handleInfoClick, this);
    this.init = __bind(this.init, this);
    var i, _i, _len, _ref,
      _this = this;
    this.data = new PWPData().data;
    this.renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight);
    this.textures = [PIXI.Texture.fromImage('img/node.png')];
    this.sketches = [];
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      this.sketches.push({
        sketch: new i.className(this.renderer),
        id: i.classId
      });
    }
    this.numSketches = this.sketches.length;
    this["interface"] = document.getElementById('interface');
    this.infoButton = document.getElementById('info-button');
    this.infoButton.onmouseover = this.handleInterfaceOver;
    this.infoButton.onmouseout = this.handleInterfaceOut;
    this.infoButton.onclick = this.handleInfoClick;
    this.menuButton = document.getElementById('menu-button');
    this.menuButton.onmouseover = this.handleInterfaceOver;
    this.menuButton.onmouseout = this.handleInterfaceOut;
    this.menuButton.onclick = this.handleMenuClick;
    this.menuPanel = new Menu(this, this.data);
    this.infoPanel = new InfoPanel();
    this.menuPanel.enable();
    window.onresize = function() {
      var sketch, _j, _len1, _ref1, _results;
      _this.infoPanel.resize();
      _this.renderer.resize(window.innerWidth, window.innerHeight);
      _ref1 = _this.sketches;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        sketch = _ref1[_j];
        _results.push(sketch.sketch.resize());
      }
      return _results;
    };
    this.init();
  }

  App.prototype.init = function() {
    window.onkeyup = this.handleKeyPress;
    return null;
  };

  App.prototype.handleInfoClick = function() {
    if (this.menuOpen) {
      this.handleMenuClick();
    }
    this.infoOpen = !this.infoOpen;
    if (this.infoOpen) {
      this.infoPanel.show();
    } else {
      this.infoPanel.hide();
    }
    return null;
  };

  App.prototype.handleMenuClick = function() {
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    this.menuOpen = !this.menuOpen;
    if (this.menuOpen) {
      this.menuPanel.show();
      TweenMax.to(this.infoButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
    } else {
      this.menuPanel.hide();
      TweenMax.to(this.menuButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
      TweenMax.to(this.infoButton, 0.5, {
        css: {
          color: '#e3e3e3'
        },
        ease: Power4.easeOut
      });
    }
    return null;
  };

  App.prototype.handleInterfaceOut = function(e) {
    TweenMax.to(e.target, 2, {
      css: {
        color: '#e3e3e3'
      },
      ease: Power4.easeOut
    });
    return null;
  };

  App.prototype.handleInterfaceOver = function(e) {
    TweenMax.to(e.target, 0.15, {
      css: {
        color: 'rgb(255, 0, 61)'
      },
      ease: Power4.easeOut
    });
    return null;
  };

  App.prototype.handleKeyPress = function(e) {
    var unicode;
    e.preventDefault();
    unicode = e.keyCode ? e.keyCode : e.charCode;
    if (unicode === 37) {
      this.prev();
    } else if (unicode === 39) {
      this.next();
    } else if (unicode === 32) {
      this.spacePressed = true;
    }
    return null;
  };

  App.prototype.next = function() {
    var lastSketch;
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('next');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.prev = function() {
    var lastSketch;
    if (this.infoOpen) {
      this.handleInfoClick();
    }
    lastSketch = this.sketches[this.currentSketch];
    this.changeSketch('prev');
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.selectSketch = function(id) {
    var lastSketch;
    lastSketch = this.sketches[this.currentSketch];
    this.currentSketch = id;
    this.unloadSketch(lastSketch.sketch);
    this.menuPanel.updateInfoContent();
    return null;
  };

  App.prototype.unloadSketch = function(sketch) {
    var _this = this;
    TweenMax.to(sketch.view, 1, {
      css: {
        opacity: 0
      },
      ease: Power4.easeOut,
      onComplete: function() {
        sketch.unload();
        return _this.loadCurrentSketch();
      }
    });
    return null;
  };

  App.prototype.changeSketch = function(dir) {
    if (dir === 'next') {
      this.currentSketch++;
    } else if (dir === 'prev') {
      this.currentSketch--;
    }
    if (this.currentSketch === this.sketches.length) {
      this.currentSketch = 0;
    } else if (this.currentSketch < 0) {
      this.currentSketch = this.sketches.length - 1;
    }
    return null;
  };

  App.prototype.loadCurrentSketch = function() {
    this.sketches[this.currentSketch].sketch.load();
    this.sketches[this.currentSketch].sketch.view.style.opacity = 0;
    document.body.appendChild(this.sketches[this.currentSketch].sketch.view);
    TweenMax.to(this.sketches[this.currentSketch].sketch.view, 1, {
      css: {
        opacity: 1
      },
      ease: Power4.easeOut
    });
    return null;
  };

  return App;

})();
